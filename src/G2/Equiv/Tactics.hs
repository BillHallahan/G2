{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TupleSections #-}

module G2.Equiv.Tactics
    ( module G2.Equiv.Types
    , TacticResult (..)
    , Tactic

    , Lemmas (..)
    , ProposedLemma
    , ProvenLemma
    , DisprovenLemma

    , isSWHNF
    , tryEquality
    , moreRestrictiveEqual
    , tryCoinduction
    , exprExtract
    , moreRestrictivePairAux
    , exprReadyForSolver
    , checkObligations
    , applySolver
    , backtrackOne
    , prevFiltered
    , syncSymbolic
    , syncEnvs

    , emptyLemmas
    , insertProposedLemma
    , proposedLemmas
    , replaceProposedLemmas
    , insertProvenLemma
    , provenLemmas

    , disprovenLemmas
    , insertDisprovenLemma

    , mkProposedLemma
    , checkCycle
    )
    where

-- TODO may not need all imports

import G2.Language

import qualified Control.Monad.State.Lazy as CM

import qualified G2.Language.ExprEnv as E
import G2.Language.Monad.AST
import qualified G2.Language.Typing as T

import GHC.Generics (Generic)
import Data.List
import Data.Maybe
import Data.Tuple
import Data.Hashable
import qualified Data.HashSet as HS
import qualified G2.Solver as S

import qualified G2.Language.PathConds as P

import G2.Equiv.G2Calls
import G2.Equiv.Types

import Data.Either
import Data.Either.Extra
import qualified Data.HashMap.Lazy as HM
import Data.Monoid ((<>))

import G2.Execution.NormalForms
import Control.Monad
import Control.Monad.Extra

import G2.Execution.Reducer

import qualified Control.Monad.Writer.Lazy as W

import Control.Exception

import Debug.Trace

-- the Bool value for Failure is True if a cycle has been found
data TacticResult = Success (Maybe (Int, Int, StateET, StateET))
                  | NoProof [Lemma]
                  | Failure Bool

-- this takes a list of fresh names as input
-- equality and coinduction don't need them
-- induction just needs one
type Tactic s = s ->
                HS.HashSet Name ->
                Lemmas ->
                [Name] ->
                (StateH, StateH) ->
                (StateET, StateET) ->
                W.WriterT [Marker] IO TacticResult

stripTicks :: Expr -> Expr
stripTicks (Tick _ e) = e
stripTicks e = e

exprReadyForSolver :: ExprEnv -> Expr -> Bool
exprReadyForSolver h (Tick _ e) = exprReadyForSolver h e
exprReadyForSolver h (Var i) = E.isSymbolic (idName i) h && T.isPrimType (typeOf i)
exprReadyForSolver h (App f a) = exprReadyForSolver h f && exprReadyForSolver h a
exprReadyForSolver _ (Prim _ _) = True
exprReadyForSolver _ (Lit _) = True
exprReadyForSolver _ _ = False

exprExtract :: State t -> Expr
exprExtract (State { curr_expr = CurrExpr _ e }) = e

-- A Var counts as being in EVF if it's symbolic or if it's unmapped.
-- TODO remove ticks recursively?
isSWHNF :: State t -> Bool
isSWHNF (State { expr_env = h, curr_expr = CurrExpr _ e }) =
  let e' = modifyASTs stripTicks e
  in case e' of
    Var _ -> isPrimType (typeOf e') && isExprValueForm h e'
    _ -> isExprValueForm h e'

-- All the PathConds that this receives are generated by symbolic execution.
-- Consequently, non-primitive types are not an issue here.
extractCond :: PathCond -> Expr
extractCond (ExtCond e True) = e
extractCond (ExtCond e False) = App (Prim Not TyUnknown) e
extractCond (AltCond l e True) =
  App (App (Prim Eq TyUnknown) e) (Lit l)
extractCond (AltCond l e False) =
  App (App (Prim Neq TyUnknown) e) (Lit l)
extractCond _ = error "Not Supported"

prevFull :: (StateH, StateH) -> [(StateET, StateET)]
prevFull (sh1, sh2) = [(p1, p2) | p1 <- history sh1, p2 <- history sh2]

-- The conditions for expr-value form do not align exactly with SWHNF.
-- A symbolic variable is in SWHNF only if it is of primitive type.
prevFiltered :: (StateH, StateH) -> [(StateET, StateET)]
prevFiltered =
  let neitherSWHNF (s1, s2) = not (isSWHNF s1 || isSWHNF s2)
  in (filter neitherSWHNF) . prevFull

-- s1 is old state, s2 is new state
-- only apply to old-new state pairs for which moreRestrictive works
moreRestrictivePC :: (W.MonadIO m, S.Solver solver) =>
                     solver ->
                     StateET ->
                     StateET ->
                     HM.HashMap Id Expr ->
                     m Bool
moreRestrictivePC solver s1 s2 hm = do
  let new_conds = map extractCond (P.toList $ path_conds s2)
      old_conds = map extractCond (P.toList $ path_conds s1)
      l = map (\(i, e) -> (Var i, e)) $ HM.toList hm
      -- this should only be used with primitive types
      -- no apparent problems come from using TyUnknown
      l' = map (\(e1, e2) ->
                  if (T.isPrimType $ typeOf e1) && (T.isPrimType $ typeOf e2)
                  then Just $ App (App (Prim Eq TyUnknown) e1) e2
                  else Nothing) l
      l'' = [c | Just c <- l']
      new_conds' = l'' ++ new_conds
      -- not safe to use unless the lists are non-empty
      conj_new = foldr1 (\o1 o2 -> App (App (Prim And TyUnknown) o1) o2) new_conds'
      conj_old = foldr1 (\o1 o2 -> App (App (Prim And TyUnknown) o1) o2) old_conds
      imp = App (App (Prim Implies TyUnknown) conj_new) conj_old
      neg_imp = ExtCond (App (Prim Not TyUnknown) imp) True
      neg_conj = ExtCond (App (Prim Not TyUnknown) conj_old) True
  res <- if null old_conds
         then return $ S.UNSAT ()
         else if null new_conds' -- old_conds not null
         -- TODO applySolver uses states' path constraints directly
         -- Are the conditions from this being satisfied trivially?
         then W.liftIO $ applySolver solver (P.insert neg_conj P.empty) s1 s2
         else W.liftIO $ applySolver solver (P.insert neg_imp P.empty) s1 s2
  case res of
    S.UNSAT () -> return True
    _ -> return False

-- s1 is the old state, s2 is the new state
-- If any recursively-defined functions or other expressions manage to slip
-- through the cracks with the other mechanisms in place for avoiding infinite
-- inlining loops, then we can handle them here by keeping track of all of the
-- variables that have been inlined previously.
-- Keeping track of inlinings by adding to ns only lets a variable be inlined
-- on one side.  We need to have two separate lists of variables that have been
-- inlined previously so that inlinings on one side do not block any inlinings
-- that need to happen on the other side.
-- Whenever a variable is inlined, we record the expression that was on the
-- opposite side at the time.  Under the original system, a variable could not
-- be inlined at all on one side in any sub-expressions that resulted from an
-- inlining of it, and that was too restrictive.  Under the current system,
-- repeated inlinings of a variable are allowed as long as the expression on
-- the opposite side is not the same as it was when a previous inlining of the
-- same variable happened.
moreRestrictive :: StateET
                -> StateET
                -> HS.HashSet Name
                -> (HM.HashMap Id Expr, HS.HashSet (Expr, Expr))
                -> Bool -- ^ indicates whether this is part of the "active expression"
                -> [(Name, Expr)] -- ^ variables inlined previously on the LHS
                -> [(Name, Expr)] -- ^ variables inlined previously on the RHS
                -> Expr
                -> Expr
                -> Either (Maybe Lemma) (HM.HashMap Id Expr, HS.HashSet (Expr, Expr))
moreRestrictive s1@(State {expr_env = h1}) s2@(State {expr_env = h2}) ns hm active n1 n2 e1 e2 =
  let h1' = opp_env $ track s1
      h2' = opp_env $ track s2
  in case (e1, e2) of
    -- ignore all Ticks
    (Tick t1 e1', Tick t2 e2') | labeledErrorName t1 == labeledErrorName t2 -> moreRestrictive s1 s2 ns hm active n1 n2 e1' e2'
    (Tick t e1', _) | isNothing $ labeledErrorName t -> moreRestrictive s1 s2 ns hm active n1 n2 e1' e2
    (_, Tick t e2') | isNothing $ labeledErrorName t -> moreRestrictive s1 s2 ns hm active n1 n2 e1 e2'
    (Var i, _) | m <- idName i
               , not $ isSymbolicBoth m h1 h1'
               , not $ HS.member m ns
               , not $ (m, e2) `elem` n1
               , Just e <- lookupBoth m h1 h1' ->
                 moreRestrictive s1 s2 ns hm active ((m, e2):n1) n2 e e2
    (_, Var i) | m <- idName i
               , not $ isSymbolicBoth m h2 h2'
               , not $ HS.member m ns
               , not $ (m, e1) `elem` n2
               , Just e <- lookupBoth m h2 h2' ->
                 moreRestrictive s1 s2 ns hm active n1 ((m, e1):n2) e1 e
    (Var i1, Var i2) | HS.member (idName i1) ns
                     , idName i1 == idName i2 -> Right hm
                     | HS.member (idName i1) ns -> Left Nothing
                     | HS.member (idName i2) ns -> Left Nothing
    (Var i, _) | isSymbolicBoth (idName i) h1 h1'
               , (hm', hs) <- hm
               , Nothing <- HM.lookup i hm' -> Right (HM.insert i (inlineEquiv [] h2 h2' ns e2) hm', hs)
               | isSymbolicBoth (idName i) h1 h1'
               , Just e <- HM.lookup i (fst hm)
               , e == inlineEquiv [] h2 h2' ns e2 -> Right hm
               -- this last case means there's a mismatch
               | isSymbolicBoth (idName i) h1 h1' -> Left Nothing
               | not $ (idName i, e2) `elem` n1
               , not $ HS.member (idName i) ns -> error $ "unmapped variable " ++ (show i)
    (_, Var i) | isSymbolicBoth (idName i) h2 h2' -> Left Nothing -- sym replaces non-sym
               | not $ (idName i, e1) `elem` n2
               , not $ HS.member (idName i) ns -> error $ "unmapped variable " ++ (show i)
    (App f1 a1, App f2 a2) | Right hm_fa <- moreResFA -> Right hm_fa
                           | Left (Just _) <- moreResFA -> moreResFA
                           | not (hasFuncType e1)
                           , not (hasFuncType e2)
                           , not active
                           , Var (Id m1 _):_ <- unApp (modifyASTs stripTicks e1)
                           , Var (Id m2 _):_ <- unApp (modifyASTs stripTicks e2)
                           , nameOcc m1 == nameOcc m2 ->
                                let
                                    v_rep = HM.toList $ fst hm
                                    e1' = replaceVars e1 v_rep
                                    -- TODO consolidate into one map
                                    -- cs doesn't get unmapped things from the other side
                                    cs (E.Conc e_) = E.Conc e_
                                    cs (E.Sym i_) = case E.lookupConcOrSym (idName i_) h2' of
                                      Nothing -> E.Sym i_
                                      Just c -> c
                                    --h2_ = E.mapConcOrSym cs h2
                                    -- TODO changing this from h2 didn't help
                                    h2_ = envMerge (E.mapConcOrSym cs h2) h2'
                                    h2_' = E.mapConc (flip replaceVars v_rep) h2_ -- foldr (\(Id n _, e) -> E.insert n e) h2 (HM.toList $ fst hm)
                                    et' = (track s2) { opp_env = E.empty }
                                    ls1 = s2 { expr_env = h2_', curr_expr = CurrExpr Evaluate e1', track = et' }
                                    ls2 = s2 { expr_env = h2_, curr_expr = CurrExpr Evaluate e2, track = et' }

                                    -- TODO do these need any adjustments?
                                    in1 = inlineFull (HS.toList ns) h1 h1'
                                    in2 = inlineFull (HS.toList ns) h2 h2'
                                in
                                -- let pg = mkPrettyGuide (ls1, ls2) in
                                -- trace ("LEMMA " ++ (folder_name $ track s2) ++ " " ++ (folder_name $ track s1)
                                --                 ++ " -\ncurr_expr s1 = " ++ printHaskellDirtyPG pg (in1 $ exprExtract s1)
                                --                 ++ "\ncurr_expr s2 = " ++ printHaskellDirtyPG pg (in2 $ exprExtract s2)
                                --                 ++ "\ne1 = " ++  printHaskellDirtyPG pg (in1 e1)
                                --                 ++ "\ne2 = " ++ printHaskellDirtyPG pg (in2 e2))
                                Left (Just $ mkProposedLemma "lemma" s1 s2 ls2 ls1)
        where
            moreResFA = do
                hm_f <- moreRestrictive s1 s2 ns hm active n1 n2 f1 f2
                moreRestrictive s1 s2 ns hm_f False n1 n2 a1 a2
    -- TODO ignoring lam use; these are never used seemingly
    -- TODO shouldn't lead to non-termination
    {-
    (App (Lam _ i b) a, _) -> let e1' = replaceASTs (Var i) a b
                              in trace ("LAM L" ++ show i) $ moreRestrictive s1 s2 ns hm n1 n2 e1' e2
    (_, App (Lam _ i b) a) -> let e2' = replaceASTs (Var i) a b
                              in trace ("LAM R" ++ show i) $ moreRestrictive s1 s2 ns hm n1 n2 e1 e2'
    -}
    -- These two cases should come after the main App-App case.  If an
    -- expression pair fits both patterns, then discharging it in a way that
    -- does not add any extra proof obligations is preferable.
    (App _ _, _) | e1':_ <- unApp e1
                 , (Prim _ _) <- inlineTop [] h1 h1' e1'
                 , T.isPrimType $ typeOf e1
                 , T.isPrimType $ typeOf e2
                 , isSWHNF $ (s2 { curr_expr = CurrExpr Evaluate e2 }) ->
                                  let (hm', hs) = hm
                                  in Right (hm', HS.insert (inlineFull [] h1 h1' e1, inlineFull [] h2 h2' e2) hs)
    (_, App _ _) | e2':_ <- unApp e2
                 , (Prim _ _) <- inlineTop [] h1 h1' e2'
                 , T.isPrimType $ typeOf e2
                 , T.isPrimType $ typeOf e1
                 , isSWHNF $ (s1 { curr_expr = CurrExpr Evaluate e1 }) ->
                                  let (hm', hs) = hm
                                  in Right (hm', HS.insert (inlineFull [] h1 h1' e1, inlineFull [] h2 h2' e2) hs)
    -- We just compare the names of the DataCons, not the types of the DataCons.
    -- This is because (1) if two DataCons share the same name, they must share the
    -- same type, but (2) "the same type" may be represented in different syntactic
    -- ways, most significantly bound variable names may differ
    -- "forall a . a" is the same type as "forall b . b", but fails a syntactic check.
    (Data (DataCon d1 _), Data (DataCon d2 _))
                                  | d1 == d2 -> Right hm
                                  | otherwise -> Left Nothing
    -- We neglect to check type equality here for the same reason.
    (Prim p1 _, Prim p2 _) | p1 == p2 -> Right hm
                           | otherwise -> Left Nothing
    (Lit l1, Lit l2) | l1 == l2 -> Right hm
                     | otherwise -> Left Nothing
    (Lam lu1 i1 b1, Lam lu2 i2 b2)
                | lu1 == lu2
                , i1 == i2 ->
                  let ns' = HS.insert (idName i1) ns
                  -- no need to insert twice over because they're equal
                  in moreRestrictive s1 s2 ns' hm active n1 n2 b1 b2
                | otherwise -> Left Nothing
    -- ignore types, like in exprPairing
    (Type _, Type _) -> Right hm
    -- new Let handling
    -- TODO does this not account for bindings properly?
    -- TODO only works properly if both binding lists are the same length
    -- I can just discard cases where they aren't for now
    (Let binds1 e1', Let binds2 e2') ->
                let pairs = (e1', e2'):(zip (map snd binds1) (map snd binds2))
                    ins (i_, e_) h_ = E.insert (idName i_) e_ h_
                    h1_ = foldr ins h1 binds1
                    h2_ = foldr ins h2 binds2
                    s1' = s1 { expr_env = h1_ }
                    s2' = s2 { expr_env = h2_ }
                    mf hm_ (e1_, e2_) = moreRestrictive s1' s2' ns hm_ active n1 n2 e1_ e2_
                in
                if length binds1 == length binds2
                then foldM mf hm pairs
                else Left Nothing
    -- TODO if scrutinee is symbolic var, make Alt vars symbolic?
    -- TODO id equality never checked; does it matter?
    (Case e1' i1 a1, Case e2' i2 a2)
                | Right hm' <- b_mr ->
                  -- add the matched-on exprs to the envs beforehand
                  -- TODO I think I can leave these E operations as they are
                  let h1_ = E.insert (idName i1) e1' h1
                      h2_ = E.insert (idName i2) e2' h2
                      s1' = s1 { expr_env = h1_ }
                      s2' = s2 { expr_env = h2_ }
                      mf hm_ (e1_, e2_) = moreRestrictiveAlt s1' s2' ns hm_ False n1 n2 e1_ e2_
                      l = zip a1 a2
                  in foldM mf hm' l
                | otherwise -> b_mr
                where
                    b_mr = moreRestrictive s1 s2 ns hm active n1 n2 e1' e2'
    (Cast e1' c1, Cast e2' c2) | c1 == c2 ->
        moreRestrictive s1 s2 ns hm active n1 n2 e1' e2'
    _ -> Left Nothing

replaceVars :: Expr -> [(Id, Expr)] -> Expr
replaceVars = foldr (\(Id n _, e) -> replaceVar n e)

-- These helper functions have safeguards to avoid cyclic inlining.
-- TODO remove ticks with this?
-- TODO these need a second expr env too
inlineTop :: [Name] -> ExprEnv -> ExprEnv -> Expr -> Expr
inlineTop acc h h' v@(Var (Id n _))
    | n `elem` acc = v
    | isSymbolicBoth n h h' = v
    | Just e <- lookupBoth n h h' = inlineTop (n:acc) h h' e
inlineTop acc h h' (Tick _ e) = inlineTop acc h h' e
inlineTop _ _ _ e = e

inlineFull :: [Name] -> ExprEnv -> ExprEnv -> Expr -> Expr
inlineFull acc h h' v@(Var (Id n _))
    | n `elem` acc = v
    | isSymbolicBoth n h h' = v
    | Just e <- lookupBoth n h h' = inlineFull (n:acc) h h' e
inlineFull acc h h' e = modifyChildren (inlineFull acc h h') e

inlineEquiv :: [Name] -> ExprEnv -> ExprEnv -> HS.HashSet Name -> Expr -> Expr
inlineEquiv acc h h' ns v@(Var (Id n _))
    | n `elem` acc = v
    | isSymbolicBoth n h h' = v
    | HS.member n ns = v
    | Just e <- lookupBoth n h h' = inlineEquiv (n:acc) h h' ns e
inlineEquiv acc h h' ns e = modifyChildren (inlineEquiv acc h h' ns) e

-- ids are the same between both sides; no need to insert twice
moreRestrictiveAlt :: StateET
                   -> StateET
                   -> HS.HashSet Name
                   -> (HM.HashMap Id Expr, HS.HashSet (Expr, Expr))
                   -> Bool -- ^ active expression?
                   -> [(Name, Expr)] -- ^ variables inlined previously on the LHS
                   -> [(Name, Expr)] -- ^ variables inlined previously on the RHS
                   -> Alt
                   -> Alt
                   -> Either (Maybe Lemma) (HM.HashMap Id Expr, HS.HashSet (Expr, Expr))
moreRestrictiveAlt s1 s2 ns hm active n1 n2 (Alt am1 e1) (Alt am2 e2) =
  if altEquiv am1 am2 then
  case am1 of
    DataAlt _ t1 -> let ns' = foldr HS.insert ns $ map idName t1
                    in moreRestrictive s1 s2 ns' hm active n1 n2 e1 e2
    _ -> moreRestrictive s1 s2 ns hm active n1 n2 e1 e2
  else Left Nothing

-- check only the names for DataAlt
altEquiv :: AltMatch -> AltMatch -> Bool
altEquiv (DataAlt dc1 ids1) (DataAlt dc2 ids2) =
  let DataCon dn1 _ = dc1
      DataCon dn2 _ = dc2
      n1 = map idName ids1
      n2 = map idName ids2
  in
  dn1 == dn2 && n1 == n2
altEquiv (LitAlt l1) (LitAlt l2) = l1 == l2
altEquiv Default Default = True
altEquiv _ _ = False

validMap :: State t -> State t -> HM.HashMap Id Expr -> Bool
validMap s1 s2 hm =
  let hm_list = HM.toList hm
      check (_, e) = (not $ isSWHNF $ s1 { curr_expr = CurrExpr Evaluate e })
                  || (not $ isSWHNF $ s2 { curr_expr = CurrExpr Evaluate e })
                  || isPrimType (typeOf e)
  in all check hm_list

validTotal :: StateET ->
              StateET ->
              HS.HashSet Name ->
              HM.HashMap Id Expr ->
              Bool
validTotal s1 s2 ns hm =
  let hm_list = HM.toList hm
      total_hs = total $ track s1
      check (i, e) = (not $ (idName i) `elem` total_hs) || (totalExpr s2 ns [] e)
  in all check hm_list

-- TODO filter the fresh vars, only check the ones in the hash map
-- TODO make sure this is sufficient to catch all the counterexamples we want
validHigherOrder :: StateET ->
                    StateET ->
                    HS.HashSet Name ->
                    Either (Maybe Lemma) (HM.HashMap Id Expr, HS.HashSet (Expr, Expr)) ->
                    Bool
validHigherOrder s1 s2 ns hm_hs | Right (hm, _) <- hm_hs =
  let -- empty these to avoid an infinite loop
      s1' = s1 { track = (track s1) { higher_order = HM.empty } }
      s2' = s2 { track = (track s2) { higher_order = HM.empty } }
      -- if the Id isn't present, the mapping isn't relevant
      hm_ids = map fst $ HM.toList hm
      -- TODO these conditions need to be looser
      -- check if the things in hm_ids have mappings, not just that they're the output of mappings
      -- TODO this new version doesn't cover inlining; I think it's too loose
      -- TODO better idea:  the new approximations can't add mappings
      -- if they do need to add mappings, disregard them
      mappings1 = HM.toList $ higher_order $ track s1
      mappings1' = filter (\(_, i) -> i `elem` hm_ids) mappings1
      mappings2 = HM.toList $ higher_order $ track s2
      mappings2' = filter (\(_, i) -> i `elem` hm_ids) mappings2
      -- TODO this can't be used now that we have a new env system
      -- also, I think it's not necessary anymore anyway
      old_pairs = filter (\(_, i) -> (E.member (idName i) (expr_env s1)) || (E.member (idName i) (opp_env $ track s1))) mappings1
      new_pairs = filter (\(_, i) -> (E.member (idName i) (expr_env s2)) || (E.member (idName i) (opp_env $ track s2))) mappings2
      old_states = map (\(e, i) -> (s1' { curr_expr = CurrExpr Evaluate e },
                                    s1' { curr_expr = CurrExpr Evaluate (Var i) })) old_pairs
      new_states = map (\(e, i) -> (s2' { curr_expr = CurrExpr Evaluate e },
                                    s2' { curr_expr = CurrExpr Evaluate (Var i) })) new_pairs
      zipped = [(p, q) | p <- old_states, q <- new_states]
      -- only current expressions change between all these states
      -- I can keep the other-side expr envs the same
      check ((p1, p2), (q1, q2)) =
        case restrictHelper p1 q1 ns hm_hs of
          Right (hm', hs') -> if HM.size hm' == HM.size hm
                              then restrictHelper p2 q2 ns (Right (hm', hs'))
                              else Right (hm', hs')
          _ -> hm_hs
  in all isRight $ map check zipped
  | otherwise = False

validTypes :: HM.HashMap Id Expr -> Bool
validTypes hm =
  all (\((Id _ t), e) -> e T..:: t) $ HM.toList hm

restrictHelper :: StateET ->
                  StateET ->
                  HS.HashSet Name ->
                  Either (Maybe Lemma) (HM.HashMap Id Expr, HS.HashSet (Expr, Expr)) ->
                  Either (Maybe Lemma) (HM.HashMap Id Expr, HS.HashSet (Expr, Expr))
restrictHelper s1 s2 ns hm_hs =
  let res = restrictAux s1 s2 ns hm_hs
  in case res of
    Right (hm, hs) -> if (validTotal s1 s2 ns hm) &&
                         --(validHigherOrder s1 s2 ns res) &&
                         (validTypes hm)
                      then Right (hm, hs)
                      else Left Nothing
    _ -> res

restrictAux :: StateET ->
               StateET ->
               HS.HashSet Name ->
               Either (Maybe Lemma) (HM.HashMap Id Expr, HS.HashSet (Expr, Expr)) ->
               Either (Maybe Lemma) (HM.HashMap Id Expr, HS.HashSet (Expr, Expr))
restrictAux s1 s2 ns (Right hm) =
  moreRestrictive s1 s2 ns hm True [] [] (exprExtract s1) (exprExtract s2)
restrictAux _ _ _ left = left

-- TODO change the opp envs?
syncSymbolic :: StateET -> StateET -> (StateET, StateET)
syncSymbolic s1 s2 =
  let et1 = (track s1) { opp_env = expr_env s2 }
      et2 = (track s2) { opp_env = expr_env s1 }
  in (s1 { track = et1 }, s2 { track = et2 })

-- the left one takes precedence
envMerge :: ExprEnv -> ExprEnv -> ExprEnv
envMerge env h =
  let f (E.SymbObj _) e2 = e2
      f e1 _ = e1
  in E.unionWith f env h

syncEnvs :: StateET -> StateET -> (StateET, StateET)
syncEnvs s1 s2 =
  let h1 = envMerge (expr_env s1) (expr_env s2)
      h2 = envMerge (expr_env s2) (expr_env s1)
  in (s1 { expr_env = h1 }, s2 { expr_env = h2 })

obligationWrap :: HS.HashSet (Expr, Expr) -> Maybe PathCond
obligationWrap obligations =
    let obligation_list = HS.toList obligations
        eq_list = map (\(e1, e2) -> App (App (Prim Eq TyUnknown) e1) e2) obligation_list
        conj = foldr1 (\o1 o2 -> App (App (Prim And TyUnknown) o1) o2) eq_list
    in
    if null eq_list
    then Nothing
    else Just $ ExtCond (App (Prim Not TyUnknown) conj) True

checkObligations :: S.Solver solver =>
                    solver ->
                    StateET ->
                    StateET ->
                    HS.HashSet (Expr, Expr) ->
                    IO (S.Result () ())
checkObligations solver s1 s2 obligation_set | not $ HS.null obligation_set =
    case obligationWrap $ modifyASTs stripTicks obligation_set of
        Nothing -> applySolver solver P.empty s1 s2
        Just allPO -> applySolver solver (P.insert allPO P.empty) s1 s2
  | otherwise = return $ S.UNSAT ()

-- shortcut:  don't invoke Z3 if there are no path conds
applySolver :: S.Solver solver =>
               solver ->
               PathConds ->
               StateET ->
               StateET ->
               IO (S.Result () ())
applySolver solver extraPC s1 s2 =
    let unionEnv = E.union (expr_env s1) (expr_env s2)
        rightPC = P.toList $ path_conds s2
        unionPC = foldr P.insert (path_conds s1) rightPC
        allPC = foldr P.insert unionPC (P.toList extraPC)
        -- TODO what if I use extraPC here instead of allPC?
        newState = s1 { expr_env = unionEnv, path_conds = extraPC }
    in case (P.toList allPC) of
      [] -> return $ S.SAT ()
      _ -> do
           {-
           putStrLn ("APPLY SOLVER " ++ (show $ folder_name $ track s1))
           putStrLn (show $ P.number $ path_conds s1)
           putStrLn (show $ folder_name $ track s2)
           putStrLn (show $ P.number $ path_conds s2)
           -}
           S.check solver newState allPC

validCoinduction :: (StateET, StateET) -> (StateET, StateET) -> Bool
validCoinduction (p1, p2) (q1, q2) =
  let dcp1 = dc_path $ track p1
      dcp2 = dc_path $ track p2
      dcq1 = dc_path $ track q1
      dcq2 = dc_path $ track q2
      consistent = dcp1 == dcp2 && dcq1 == dcq2
      unguarded = all (not . isSWHNF) [p1, p2, q1, q2]
      guarded = length dcp1 < length dcq1
  in consistent && (guarded || unguarded)

-- extra filter on top of isJust for maybe_pairs
-- if restrictHelper end result is Just, try checking the corresponding PCs
-- for True output, there needs to be an entry for which that check succeeds
-- return the previous state pair that was used for the discharge
-- return Nothing if there was no discharge
-- if there are multiple, just return the first
-- TODO first pair is "current," second pair is the match from the past
-- TODO the third entry in a prev triple is the original for left or right
-- TODO do I still need the dc path check at the start here?
moreRestrictivePairAux :: S.Solver solver =>
                          solver ->
                          ((StateET, StateET) -> (StateET, StateET) -> Bool) ->
                          HS.HashSet Name ->
                          [(StateET, StateET, StateET)] ->
                          (StateET, StateET) ->
                          W.WriterT [Marker] IO (Either [Lemma] (PrevMatch EquivTracker))
moreRestrictivePairAux solver valid ns prev (s1, s2) | dc_path (track s1) == dc_path (track s2) = do
  let (s1', s2') = syncSymbolic s1 s2
      mr (p1, p2, pc) =
          if valid (p1, p2) (s1', s2') then
            let hm_obs = let (p1', p2') = syncSymbolic p1 p2
                         in restrictHelper p2' s2' ns $
                         restrictHelper p1' s1' ns (Right (HM.empty, HS.empty))
            in
              mapLeft (fmap (\l -> l { lemma_name = "past_1 = " ++ folder p1
                                                  ++ " present_1 = " ++ folder s1
                                                  ++ " past_2 = " ++ folder p2
                                                  ++ " present_2 = " ++ folder s2  }))
            $ fmap (\hm_obs' -> PrevMatch (s1, s2) (p1, p2) hm_obs' pc) hm_obs
          else Left Nothing
      
      (possible_lemmas, possible_matches) = partitionEithers $ map mr prev

      folder = folder_name . track
      -- As a heuristic, take only lemmas where both sides are not in SWHNF
      possible_lemmas' = filter (\(Lemma { lemma_lhs = s1, lemma_rhs = s2 }) ->
                                              not (isSWHNF s1)
                                           && not (isSWHNF s2))
                       $ catMaybes possible_lemmas

      mpc (PrevMatch _ (p1, p2) (hm, _) _) =
          andM [moreRestrictivePC solver p1 s1 hm, moreRestrictivePC solver p2 s2 hm]

  possible_matches' <- filterM mpc possible_matches
  -- check obligations individually rather than as one big group
  res_list <- W.liftIO (findM (\pm -> isUnsat =<< checkObligations solver s1 s2 (snd . conditions $ pm)) (possible_matches'))
  return $ maybe (Left possible_lemmas') Right res_list
  | otherwise = return $ Left []
  where
      isUnsat (S.UNSAT _) = return True
      isUnsat _ = return False

-- the third entry in prev tuples is meaningless here
moreRestrictivePair :: S.Solver solver =>
                       solver ->
                       ((StateET, StateET) -> (StateET, StateET) -> Bool) ->
                       HS.HashSet Name ->
                       [(StateET, StateET)] ->
                       (StateET, StateET) ->
                       W.WriterT [Marker] IO (Either [Lemma] (PrevMatch EquivTracker))
moreRestrictivePair solver valid ns prev (s1, s2) =
  let prev' = map (\(p1, p2) -> (p1, p2, p2)) prev in
  moreRestrictivePairAux solver valid ns prev' (s1, s2)

moreRestrictiveSingle :: S.Solver solver =>
                         solver ->
                         HS.HashSet Name ->
                         StateET ->
                         StateET ->
                         W.WriterT [Marker] IO (Either (Maybe Lemma) (HM.HashMap Id Expr))
moreRestrictiveSingle solver ns s1 s2 = do
    case restrictHelper s1 s2 ns $ Right (HM.empty, HS.empty) of
        (Left l) -> return $ Left l
        Right (hm, obs) -> do
            more_res_pc <- moreRestrictivePC solver s1 s2 hm
            case more_res_pc of
                False -> return $ Left Nothing
                True -> do
                    obs <- W.liftIO (checkObligations solver s1 s2 obs)
                    case isUnsat obs of
                        True -> return (Right hm)
                        False -> return $ Left Nothing
    where
        isUnsat (S.UNSAT _) = True
        isUnsat _ = False

-- TODO tick adjusting here?
isIdentity :: (Id, Expr) -> Bool
isIdentity (i1, Tick _ e2) = isIdentity (i1, e2)
isIdentity (i1, (Var i2)) = i1 == i2
isIdentity _ = False

-- approximation should be the identity map
-- needs to be enforced, won't just happen naturally
moreRestrictiveEqual :: S.Solver solver =>
                        solver ->
                        HS.HashSet Name ->
                        Lemmas ->
                        StateET ->
                        StateET ->
                        W.WriterT [Marker] IO (Maybe (PrevMatch EquivTracker))
moreRestrictiveEqual solver ns lemmas s1 s2 = do
  let (s1', s2') = syncSymbolic s1 s2
  if dc_path (track s1') /= dc_path (track s2') then return Nothing
  else do
    -- no need to enforce dc path condition for this function
    pm_maybe <- moreRestrictivePairWithLemmasPast solver (\_ _ -> True) ns lemmas [(s2', s1')] (s1', s2')
    case pm_maybe of
      Left _ -> return Nothing
      Right (_, _, pm@(PrevMatch _ _ (hm, _) _)) ->
        if all isIdentity $ HM.toList hm
        then return $ Just pm
        else return Nothing

-- This attempts to find a pair of equal expressions between the left and right
-- sides.  The state used for the left side stays constant, but the recursion
-- iterates through all of the states in the right side's history.
equalFoldL :: S.Solver solver =>
              solver ->
              HS.HashSet Name ->
              Lemmas ->
              [StateET] ->
              StateET ->
              W.WriterT [Marker] IO (Maybe (PrevMatch EquivTracker))
equalFoldL solver ns lemmas prev2 s1 = do
  case prev2 of
    [] -> return Nothing
    p2:t -> do
      mre <- moreRestrictiveEqual solver ns lemmas s1 p2
      case mre of
        Just pm -> return $ Just pm
        _ -> equalFoldL solver ns lemmas t s1

-- TODO clean up code
-- This tries all of the allowable combinations for equality checking.  First
-- it tries matching the left-hand present state with all of the previously
-- encountered right-hand states.  If all of those fail, it tries matching the
-- right-hand present state with all of the previously encountered left-hand
-- states.
equalFold :: S.Solver solver =>
             solver ->
             HS.HashSet Name ->
             Lemmas ->
             (StateH, StateH) ->
             (StateET, StateET) ->
             W.WriterT [Marker] IO (Maybe (PrevMatch EquivTracker, Side))
equalFold solver ns lemmas (sh1, sh2) (s1, s2) = do
  pm_l <- equalFoldL solver ns lemmas (s2:history sh2) s1
  case pm_l of
    Just pm -> return $ Just (pm, ILeft)
    _ -> do
      pm_r <- equalFoldL solver ns lemmas (s1:history sh1) s2
      case pm_r of
        Just pm' -> return $ Just (pm', IRight)
        _ -> return Nothing

tryEquality :: S.Solver s => Tactic s
tryEquality solver ns lemmas _ sh_pair (s1, s2) = do
  res <- equalFold solver ns lemmas sh_pair (s1, s2)
  case res of
    Just (pm, sd) -> do
      let (q1, q2) = case sd of
                       ILeft -> present pm
                       IRight -> swap $ present pm
      W.tell $ [Marker sh_pair $ Equality $ EqualMarker (s1, s2) (q1, q2)]
      return $ Success Nothing
    _ -> return (NoProof [])

backtrackOne :: StateH -> Maybe StateH
backtrackOne sh =
  case history sh of
    [] -> Nothing
    h:t -> Just $ sh {
                       latest = h
                     , history = t
                     }

-- This attempts to find a past-present combination that works for coinduction.
-- The left-hand present state stays fixed, but the recursion iterates through
-- all of the possible options for the right-hand present state.
coinductionFoldL :: S.Solver solver =>
                    solver ->
                    HS.HashSet Name ->
                    Lemmas ->
                    [Lemma] ->
                    (StateH, StateH) ->
                    (StateET, StateET) ->
                    W.WriterT [Marker] IO (Either [Lemma] (Maybe (StateET, Lemma), Maybe (StateET, Lemma), PrevMatch EquivTracker))
coinductionFoldL solver ns lemmas gen_lemmas (sh1, sh2) (s1, s2) = do
  let prev = prevFull (sh1, sh2)
  res <- moreRestrictivePairWithLemmasOnFuncApps solver validCoinduction ns lemmas prev (s1', s2')
  case res of
    Right _ -> return res
    Left new_lems -> backtrack new_lems
  where
      (s1', s2') = syncSymbolic s1 s2

      backtrack new_lems_ =
          case backtrackOne sh2 of
              Nothing -> return . Left $ new_lems_ ++ gen_lemmas
              Just sh2' -> coinductionFoldL solver ns lemmas
                                       (new_lems_ ++ gen_lemmas) (sh1, sh2') (s1, latest sh2')

tryCoinduction :: S.Solver s => Tactic s
tryCoinduction solver ns lemmas _ (sh1, sh2) (s1, s2) = do
  res_l <- coinductionFoldL solver ns lemmas [] (sh1, sh2) (s1, s2)
  case res_l of
    Right (lem_l, lem_r, pm) -> do
      let cml = CoMarker {
        co_real_present = (s1, s2)
      , co_used_present = present pm
      , co_past = past pm
      , lemma_used_left = lem_l
      , lemma_used_right = lem_r
      }
      W.tell [Marker (sh1, sh2) $ Coinduction cml]
      return $ Success Nothing
    Left l_lemmas -> do
      res_r <- coinductionFoldL solver ns lemmas [] (sh2, sh1) (s2, s1)
      case res_r of
        Right (lem_l', lem_r', pm') -> do
          let cmr = CoMarker {
            co_real_present = (s2, s1)
          , co_used_present = present pm'
          , co_past = past pm'
          , lemma_used_left = lem_l'
          , lemma_used_right = lem_r'
          }
          W.tell [Marker (sh1, sh2) $ Coinduction $ reverseCoMarker cmr]
          return $ Success Nothing
        Left r_lemmas -> return . NoProof $ l_lemmas ++ r_lemmas

-------------------------------------------------------------------------------

data Lemmas = Lemmas { proposed_lemmas :: [ProposedLemma]
                     , proven_lemmas :: [ProvenLemma]
                     , disproven_lemmas :: [DisprovenLemma]}

emptyLemmas :: Lemmas
emptyLemmas = Lemmas [] [] []

insertProposedLemma :: S.Solver solver => solver -> HS.HashSet Name -> Lemma -> Lemmas -> W.WriterT [Marker] IO Lemmas
insertProposedLemma solver ns lem lems@(Lemmas { proposed_lemmas = prop_lems
                                               , proven_lemmas = proven_lems
                                               , disproven_lemmas = disproven_lems }) = do
    same_as_proposed <- equivLemma solver ns lem prop_lems
    implied_by_proven <- moreRestrictiveLemma solver ns lem proven_lems
    implied_by_disproven <- anyM (\dl -> moreRestrictiveLemma solver ns dl [lem]) disproven_lems
    case same_as_proposed || implied_by_proven  || implied_by_disproven of
        True -> return lems
        False -> return lems { proposed_lemmas = lem:prop_lems }

proposedLemmas :: Lemmas -> [ProposedLemma]
proposedLemmas = proposed_lemmas

provenLemmas :: Lemmas -> [ProposedLemma]
provenLemmas = proven_lemmas

disprovenLemmas :: Lemmas -> [ProposedLemma]
disprovenLemmas = disproven_lemmas

replaceProposedLemmas :: [ProposedLemma] -> Lemmas -> Lemmas
replaceProposedLemmas pl lems = lems { proposed_lemmas = pl }

insertProvenLemma :: ProvenLemma -> Lemmas -> Lemmas
insertProvenLemma lem lems = lems { proven_lemmas = lem:proven_lemmas lems }

insertDisprovenLemma :: DisprovenLemma -> Lemmas -> Lemmas
insertDisprovenLemma lem lems = lems { disproven_lemmas = lem:disproven_lemmas lems }

moreRestrictiveLemma :: S.Solver solver => solver -> HS.HashSet Name -> Lemma -> [Lemma] -> W.WriterT [Marker] IO Bool 
moreRestrictiveLemma solver ns (Lemma { lemma_lhs = l1_1, lemma_rhs = l1_2 }) lems = do
    mr <- moreRestrictivePair solver (\_ _ -> True) ns
                              (map (\(Lemma { lemma_lhs = l2_1, lemma_rhs = l2_2 }) -> (l2_1, l2_2)) lems)
                              (l1_1, l1_2)
    case mr of
        Left _ -> return False
        Right _ -> return True

-- TODO Is this correct?  See moreRestrictiveEqual
equivLemma :: S.Solver solver => solver -> HS.HashSet Name -> Lemma -> [Lemma] -> W.WriterT [Marker] IO Bool 
equivLemma solver ns (Lemma { lemma_lhs = l1_1, lemma_rhs = l1_2 }) lems = do
    anyM (\(Lemma { lemma_lhs = l2_1, lemma_rhs = l2_2 }) -> do
                    mr1 <- moreRestrictivePair solver (\_ _ -> True) ns [(l2_1, l2_2)] (l1_1, l1_2)
                    mr2 <- moreRestrictivePair solver (\_ _ -> True) ns [(l1_1, l1_2)] (l2_1, l2_2)
                    case (mr1, mr2) of
                        (Right _, Right _) -> return True
                        _ -> return False) lems

filterProvenLemmas :: (Lemma -> Bool) -> Lemmas -> Lemmas
filterProvenLemmas p lems@(Lemmas { proven_lemmas = prov }) = lems { proven_lemmas = filter p prov }

-- TODO: Does substLemma need to do something more to check correctness of path constraints?
-- `substLemma state lemmas` tries to apply each proven lemma in `lemmas` to `state`.
-- In particular, for each `lemma = (lemma_l `equiv lemma_r` in the proven lemmas, it
-- searches for a subexpression `e'` of `state`'s current expression such that `e' <=_V lemma_l`.
-- If it find such a subexpression, it adds state[e'[V(x)/x]] to the returned
-- list of States.
substLemma :: S.Solver solver =>
              solver ->
              HS.HashSet Name ->
              StateET ->
              Lemmas ->
              W.WriterT [Marker] IO [(Lemma, StateET)]
substLemma solver ns s =
    mapMaybeM (\lem -> replaceMoreRestrictiveSubExpr solver ns lem s) . provenLemmas

replaceMoreRestrictiveSubExpr :: S.Solver solver =>
                                 solver ->
                                 HS.HashSet Name ->
                                 Lemma ->
                                 StateET ->
                                 W.WriterT [Marker] IO (Maybe (Lemma, StateET))
replaceMoreRestrictiveSubExpr solver ns lemma s@(State { curr_expr = CurrExpr er _ }) = do
    (e, replaced) <- CM.runStateT (replaceMoreRestrictiveSubExpr' solver ns lemma s $ exprExtract s) Nothing
    case replaced of
      Nothing -> return Nothing
      Just new_vars -> let new_ids = map fst new_vars
                           h = foldr E.insertSymbolic (expr_env s) new_ids
                           new_total = map (idName . fst) $ filter snd new_vars
                           total' = foldr HS.insert (total $ track s) new_total
                           track' = (track s) { total = total' }
                           s' = s {
                             curr_expr = CurrExpr er e
                           , expr_env = h
                           , track = track'
                           }
                       in return $ Just (lemma, s')

{-
If a symbolic variable is on the RHS of a lemma but not the LHS, add it to the
expression environment of the state receiving the substitution.
No need to carry over concretized ones because of inlineFull.
Get all of the symbolic IDs that are not in v_rep from the lemma RHS.
Keep track of totality info for variables that get migrated.
If the variable is concrete in one location but symbolic in another, making the
substitution from the symbolic place to the concrete place is still valid.
If it's unmapped, put it in as symbolic.
If it's concrete or symbolic, just leave it as it is.
This implementation does not cover finiteness information.
-}
replaceMoreRestrictiveSubExpr' :: S.Solver solver =>
                                  solver ->
                                  HS.HashSet Name ->
                                  Lemma ->
                                  StateET ->
                                  Expr ->
                                  CM.StateT (Maybe [(Id, Bool)]) (W.WriterT [Marker] IO) Expr
replaceMoreRestrictiveSubExpr' solver ns lemma@(Lemma { lemma_lhs = lhs_s, lemma_rhs = rhs_s })
                                         s2@(State { curr_expr = CurrExpr er _ }) e = do
    replaced <- CM.get
    if isNothing replaced then do
        mr_sub <- CM.lift $ moreRestrictiveSingle solver ns lhs_s (s2 { curr_expr = CurrExpr Evaluate e })
        case mr_sub of
            Right hm -> do
                let v_rep = HM.toList hm
                    -- TODO do I need both sides?
                    ids_l = E.symbolicIds $ opp_env $ track rhs_s
                    ids_r = E.symbolicIds $ expr_env rhs_s
                    ids = nub (ids_l ++ ids_r)
                    new_ids = filter (\(Id n _) -> not (E.member n (expr_env s2) || E.member n (opp_env $ track s2))) ids
                    new_info = map (\(Id n _) -> n `elem` (total $ track rhs_s)) new_ids
                    -- TODO make sure this modification is correct
                    -- should it be opp_env instead of the LHS?
                    rhs_e' = replaceVars (inlineFull (HS.toList ns) (expr_env rhs_s) (opp_env $ track rhs_s) $ exprExtract rhs_s) v_rep
                CM.put $ Just $ zip new_ids new_info
                return rhs_e'
            Left _ -> do
                let ns' = foldr HS.insert ns (bind e)
                modifyChildrenM (replaceMoreRestrictiveSubExpr' solver ns' lemma s2) e
    else return e
    where
        bind (Lam _ i _) = [idName i]
        bind (Case _ i as) = idName i:concatMap altBind as
        bind (Let b _) = map (idName . fst) b
        bind _ = []

        altBind (Alt (DataAlt _ is) _) = map idName is
        altBind _ = []

-- Tries to apply lemmas to expressions only in FAF form, and only if the function being applied can not be
-- called in any way by the lemma.
moreRestrictivePairWithLemmasOnFuncApps :: S.Solver solver =>
                                           solver ->
                                           ((StateET, StateET) -> (StateET, StateET) -> Bool) ->
                                           HS.HashSet Name ->
                                           Lemmas ->
                                           [(StateET, StateET)] ->
                                           (StateET, StateET) ->
                                           W.WriterT [Marker] IO (Either [Lemma] (Maybe (StateET, Lemma), Maybe (StateET, Lemma), PrevMatch EquivTracker))
moreRestrictivePairWithLemmasOnFuncApps solver valid ns =
    moreRestrictivePairWithLemmas'
        (\s s' lem -> case unApp . modifyASTs stripTicks . inlineFull (HS.toList ns) (expr_env s) (expr_env s') $ exprExtract s of
                    Var (Id f _):_ ->
                        let
                            lem_vars = varNames $ inlineFull (HS.toList ns) (expr_env s) (expr_env s') $ exprExtract (lemma_rhs lem)
                        in
                        not $ f `elem` lem_vars
                    _ -> False)
        solver valid ns
--     | Var (Id f1 _):_ <- unApp $ exprExtract s1
--     , Var (Id f2 _):_ <- unApp $ exprExtract s2 = do
--         moreRestrictivePairWithLemmas solver ns lemmas past (s1, s2)
--     | otherwise = do
--         mrp <- moreRestrictivePair solver ns past (s1, s2)
--         return $ fmap (Nothing, Nothing,) mrp

moreRestrictivePairWithLemmas :: S.Solver solver =>
                                 solver ->
                                 ((StateET, StateET) -> (StateET, StateET) -> Bool) ->
                                 HS.HashSet Name ->
                                 Lemmas ->
                                 [(StateET, StateET)] ->
                                 (StateET, StateET) ->
                                 W.WriterT [Marker] IO (Either [Lemma] (Maybe (StateET, Lemma), Maybe (StateET, Lemma), PrevMatch EquivTracker))
moreRestrictivePairWithLemmas = moreRestrictivePairWithLemmas' (\_ _ _ -> True)

moreRestrictivePairWithLemmas' :: S.Solver solver =>
                                  (StateET -> StateET -> Lemma -> Bool) ->
                                  solver ->
                                  ((StateET, StateET) -> (StateET, StateET) -> Bool) ->
                                  HS.HashSet Name ->
                                  Lemmas ->
                                  [(StateET, StateET)] ->
                                  (StateET, StateET) ->
                                  W.WriterT [Marker] IO (Either [Lemma] (Maybe (StateET, Lemma), Maybe (StateET, Lemma), PrevMatch EquivTracker))
moreRestrictivePairWithLemmas' app_state solver valid ns lemmas past (s1, s2) = do
    let (s1', s2') = syncSymbolic s1 s2
    xs1 <- substLemma solver ns s1' $ filterProvenLemmas (app_state s1' s2') lemmas
    xs2 <- substLemma solver ns s2' $ filterProvenLemmas (app_state s2' s1') lemmas

    let xs1' = (Nothing, s1'):(map (\(l, s) -> (Just l, s)) xs1)
        xs2' = (Nothing, s2'):(map (\(l, s) -> (Just l, s)) xs2)
        pairs = [ (pair1, pair2) | pair1 <- xs1', pair2 <- xs2' ]

    rp <- mapM (\((l1, s1_), (l2, s2_)) -> do
            mrp <- moreRestrictivePair solver valid ns past (s1_, s2_)
            -- TODO use synced or non-synced?
            let l1' = case l1 of
                  Nothing -> Nothing
                  Just lem1 -> Just (s1', lem1)
                l2' = case l2 of
                  Nothing -> Nothing
                  Just lem2 -> Just (s2', lem2)
            return $ fmap (l1', l2', ) mrp) pairs
    let (possible_lemmas, possible_matches) = partitionEithers rp

    case possible_matches of
        x:_ -> return $ Right x
        [] -> return . Left $ concat possible_lemmas

-- TODO have a cleaner setup for these variations
moreRestrictivePairWithLemmasPast :: S.Solver solver =>
                                     solver ->
                                     ((StateET, StateET) -> (StateET, StateET) -> Bool) ->
                                     HS.HashSet Name ->
                                     Lemmas ->
                                     [(StateET, StateET)] ->
                                     (StateET, StateET) ->
                                     W.WriterT [Marker] IO (Either [Lemma] (Maybe (StateET, Lemma), Maybe (StateET, Lemma), PrevMatch EquivTracker))
moreRestrictivePairWithLemmasPast solver valid ns lemmas past s_pair = do
    let (past1, past2) = unzip past
    xs_past1 <- mapM (\(q1, q2) -> substLemma solver ns q1 lemmas) past
    xs_past2 <- mapM (\(q1, q2) -> substLemma solver ns q2 lemmas) past
    let plain_past1 = map (\s_ -> (Nothing, s_)) past1
        plain_past2 = map (\s_ -> (Nothing, s_)) past2
        xs_past1' = plain_past1 ++ (map (\(l, s) -> (Just l, s)) $ concat xs_past1)
        xs_past2' = plain_past2 ++ (map (\(l, s) -> (Just l, s)) $ concat xs_past2)
        -- TODO is it fine to sync after lemma usage rather than before?
        -- TODO also record the lemmas used somehow?
        pair_past (_, p1) (_, p2) = syncSymbolic p1 p2
        past' = [pair_past pair1 pair2 | pair1 <- xs_past1', pair2 <- xs_past2']
    moreRestrictivePairWithLemmas solver valid ns lemmas past' s_pair

-- TODO I think this assertion is no longer needed
-- I can do some sort of merge for the expression environments
-- TODO this won't fetch new symbolic Ids for either side
mkProposedLemma :: String -> StateET -> StateET -> StateET -> StateET -> ProposedLemma
mkProposedLemma lm_name or_s1 or_s2 s1 s2 =
    let h1 = expr_env s1
        h2 = expr_env s2
        cs h (E.Conc e) = E.Conc e
        cs h (E.Sym i) = case E.lookupConcOrSym (idName i) h of
          Nothing -> E.Sym i
          Just c -> c
        h1' = E.mapConcOrSym (cs h2) h1
        h2' = E.mapConcOrSym (cs h1) h2
        -- TODO this is copied from syncSymbolic, and it's inefficient
        f (E.SymbObj _) e2 = e2
        f e1 _ = e1
        -- TODO not sure why this is necessary or helpful
        h1'' = E.unionWith f h1' h2'
        h2'' = E.unionWith f h2' h1'
        s1' = s1 { expr_env = h1'' }
        s2' = s2 { expr_env = h2'' }
    in
    assert (map idName (E.symbolicIds (expr_env s1')) == map idName (E.symbolicIds (expr_env s2')))
          Lemma { lemma_name = lm_name
                , lemma_lhs = s1'
                , lemma_rhs = s2'
                , lemma_lhs_origin = folder_name . track $ or_s1
                , lemma_rhs_origin = folder_name . track $ or_s2
                , lemma_to_be_proven  =[(newStateH s1', newStateH s2')] }

-- cycle detection
-- TODO do I need to be careful about thrown-out Data constructors?
-- that doesn't matter for checking latest states
checkCycle :: S.Solver s => Tactic s
checkCycle solver ns _ _ (sh1, sh2) (s1, s2) = do
  --W.liftIO $ putStrLn $ "Cycle?" ++ (folder_name $ track s1) ++ (folder_name $ track s2)
  let (s1', s2') = syncSymbolic s1 s2
      hist1 = filter (\p -> dc_path (track p) == dc_path (track s1')) $ history sh1
      hist2 = filter (\p -> dc_path (track p) == dc_path (track s2')) $ history sh2
      hist1' = zip hist1 (map expr_env hist2)
      hist2' = zip hist2 (map expr_env hist1)
  -- TODO this relies on histories being the same length and having matching entries
  -- I think I'm fine in that regard
  -- TODO not syncing the past states; does it matter?
  -- the concretization I need to get is in the present
  -- TODO doing extra opp_env stuff here for the past doesn't help
  mr1 <- mapM (\(p1, hp2) -> moreRestrictiveSingle solver ns s1' (p1 { track = (track p1) { opp_env = hp2 } })) hist1'
  mr2 <- mapM (\(p2, hp1) -> moreRestrictiveSingle solver ns s2' (p2 { track = (track p2) { opp_env = hp1 } })) hist2'
  let vh s (Left _, _) = False
      vh s (Right hm, p) = validHigherOrder s p ns $ Right (hm, HS.empty)
      mr1_pairs = zip mr1 hist1
      mr1_pairs' = filter (vh s1') mr1_pairs
      mr1_pair = find (isRight . fst) mr1_pairs'
      mr2_pairs = zip mr2 hist2
      mr2_pairs' = filter (vh s2') mr2_pairs
      mr2_pair = find (isRight . fst) mr2_pairs'
  case (isSWHNF s1', isSWHNF s2', mr2_pair) of
    (True, False, Just (Right hm, p2)) -> do
      W.tell [Marker (sh1, sh2) $ CycleFound $ CycleMarker (s1, s2) p2 hm IRight]
      return $ Failure True
    _ -> case (isSWHNF s1', isSWHNF s2', mr1_pair) of
      (False, True, Just (Right hm, p1)) -> do
        W.tell [Marker (sh1, sh2) $ CycleFound $ CycleMarker (s1, s2) p1 hm ILeft]
        return $ Failure True
      _ -> return $ NoProof []
