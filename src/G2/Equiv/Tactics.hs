{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TupleSections #-}

module G2.Equiv.Tactics
    ( module G2.Equiv.Types
    , TacticResult (..)
    , Tactic
    , TacticM

    , Lemmas (..)
    , ProposedLemma
    , ProvenLemma
    , DisprovenLemma

    , isSWHNF
    , tryEquality
    , moreRestrictiveEqual
    , tryCoinduction
    , exprExtract
    , moreRestrictivePairAux
    , exprReadyForSolver
    , checkObligations
    , applySolver
    , backtrackOne
    , prevFiltered

    , emptyLemmas
    , insertProposedLemma
    , proposedLemmas
    , replaceProposedLemmas
    , insertProvenLemma
    , provenLemmas

    , disprovenLemmas
    , insertDisprovenLemma

    , mkProposedLemma
    )
    where

-- TODO may not need all imports

import G2.Language

import qualified Control.Monad.State.Lazy as CM

import qualified G2.Language.ExprEnv as E
import G2.Language.Monad.AST
import G2.Language.Monad
import qualified G2.Language.Typing as T
import G2.Lib.Printers

import GHC.Generics (Generic)
import Data.Maybe
import Data.Tuple
import Data.Hashable
import qualified Data.HashSet as HS
import qualified G2.Solver as S

import qualified G2.Language.PathConds as P

import G2.Equiv.G2Calls
import G2.Equiv.Types

import Data.Either
import Data.Either.Extra
import qualified Data.HashMap.Lazy as HM
import Data.Monoid ((<>))

import G2.Execution.NormalForms
import Control.Monad
import Control.Monad.Extra

import G2.Execution.Reducer

import qualified Control.Monad.State.Lazy as SM
import qualified Control.Monad.Writer.Lazy as W

import Control.Exception

data TacticResult = Success (Maybe (Int, Int, StateET, StateET))
                  | NoProof (HS.HashSet Lemma)
                  | Failure

type TacticM = SM.StateT NameGen (W.WriterT [Marker] IO)

-- this takes a list of fresh names as input
-- equality and coinduction don't need them
-- induction just needs one
type Tactic s = s ->
                HS.HashSet Name ->
                Lemmas ->
                [Name] ->
                (StateH, StateH) ->
                (StateET, StateET) ->
                TacticM TacticResult

stripTicks :: Expr -> Expr
stripTicks (Tick _ e) = e
stripTicks e = e

exprReadyForSolver :: ExprEnv -> Expr -> Bool
exprReadyForSolver h (Tick _ e) = exprReadyForSolver h e
exprReadyForSolver h (Var i) = E.isSymbolic (idName i) h && T.isPrimType (typeOf i)
exprReadyForSolver h (App f a) = exprReadyForSolver h f && exprReadyForSolver h a
exprReadyForSolver _ (Prim _ _) = True
exprReadyForSolver _ (Lit _) = True
exprReadyForSolver _ _ = False

exprExtract :: State t -> Expr
exprExtract (State { curr_expr = CurrExpr _ e }) = e

-- A Var counts as being in EVF if it's symbolic or if it's unmapped.
-- TODO remove ticks recursively?
isSWHNF :: State t -> Bool
isSWHNF (State { expr_env = h, curr_expr = CurrExpr _ e }) =
  let e' = modifyASTs stripTicks e
  in case e' of
    Var _ -> isPrimType (typeOf e') && isExprValueForm h e'
    _ -> isExprValueForm h e'

-- All the PathConds that this receives are generated by symbolic execution.
-- Consequently, non-primitive types are not an issue here.
extractCond :: PathCond -> Expr
extractCond (ExtCond e True) = e
extractCond (ExtCond e False) = App (Prim Not TyUnknown) e
extractCond (AltCond l e True) =
  App (App (Prim Eq TyUnknown) e) (Lit l)
extractCond (AltCond l e False) =
  App (App (Prim Neq TyUnknown) e) (Lit l)
extractCond _ = error "Not Supported"

prevFull :: (StateH, StateH) -> [(StateET, StateET)]
prevFull (sh1, sh2) = [(p1, p2) | p1 <- history sh1, p2 <- history sh2]

-- The conditions for expr-value form do not align exactly with SWHNF.
-- A symbolic variable is in SWHNF only if it is of primitive type.
prevFiltered :: (StateH, StateH) -> [(StateET, StateET)]
prevFiltered =
  let neitherSWHNF (s1, s2) = not (isSWHNF s1 || isSWHNF s2)
  in (filter neitherSWHNF) . prevFull

-- s1 is old state, s2 is new state
-- only apply to old-new state pairs for which moreRestrictive works
moreRestrictivePC :: (W.MonadIO m, S.Solver solver) =>
                     solver ->
                     StateET ->
                     StateET ->
                     HM.HashMap Id Expr ->
                     m Bool
moreRestrictivePC solver s1 s2 hm = do
  let new_conds = map extractCond (P.toList $ path_conds s2)
      old_conds = map extractCond (P.toList $ path_conds s1)
      l = map (\(i, e) -> (Var i, e)) $ HM.toList hm
      -- this should only be used with primitive types
      -- no apparent problems come from using TyUnknown
      l' = map (\(e1, e2) ->
                  if (T.isPrimType $ typeOf e1) && (T.isPrimType $ typeOf e2)
                  then Just $ App (App (Prim Eq TyUnknown) e1) e2
                  else Nothing) l
      l'' = [c | Just c <- l']
      new_conds' = l'' ++ new_conds
      -- not safe to use unless the lists are non-empty
      conj_new = foldr1 (\o1 o2 -> App (App (Prim And TyUnknown) o1) o2) new_conds'
      conj_old = foldr1 (\o1 o2 -> App (App (Prim And TyUnknown) o1) o2) old_conds
      imp = App (App (Prim Implies TyUnknown) conj_new) conj_old
      neg_imp = ExtCond (App (Prim Not TyUnknown) imp) True
      neg_conj = ExtCond (App (Prim Not TyUnknown) conj_old) True
  res <- if null old_conds
         then return $ S.UNSAT ()
         else if null new_conds' -- old_conds not null
         -- TODO applySolver uses states' path constraints directly
         -- Are the conditions from this being satisfied trivially?
         then W.liftIO $ applySolver solver (P.insert neg_conj P.empty) s1 s2
         else W.liftIO $ applySolver solver (P.insert neg_imp P.empty) s1 s2
  case res of
    S.UNSAT () -> return True
    _ -> return False

-- s1 is the old state, s2 is the new state
-- If any recursively-defined functions or other expressions manage to slip
-- through the cracks with the other mechanisms in place for avoiding infinite
-- inlining loops, then we can handle them here by keeping track of all of the
-- variables that have been inlined previously.
-- Keeping track of inlinings by adding to ns only lets a variable be inlined
-- on one side.  We need to have two separate lists of variables that have been
-- inlined previously so that inlinings on one side do not block any inlinings
-- that need to happen on the other side.
-- Whenever a variable is inlined, we record the expression that was on the
-- opposite side at the time.  Under the original system, a variable could not
-- be inlined at all on one side in any sub-expressions that resulted from an
-- inlining of it, and that was too restrictive.  Under the current system,
-- repeated inlinings of a variable are allowed as long as the expression on
-- the opposite side is not the same as it was when a previous inlining of the
-- same variable happened.
moreRestrictive :: StateET ->
                   StateET ->
                   HS.HashSet Name ->
                   (HM.HashMap Id Expr, HS.HashSet (Expr, Expr)) ->
                   Bool -> -- indicates whether this is part of the "active expression"
                   [(Name, Expr)] -> -- ^ variables inlined previously on the LHS
                   [(Name, Expr)] -> -- ^ variables inlined previously on the RHS
                   Expr ->
                   Expr ->
                   Either (Maybe (Expr, Lemma)) (HM.HashMap Id Expr, HS.HashSet (Expr, Expr))
moreRestrictive s1@(State {expr_env = h1}) s2@(State {expr_env = h2}) ns hm active n1 n2 e1 e2 =
  case (e1, e2) of
    -- ignore all Ticks
    (Tick _ e1', _) -> moreRestrictive s1 s2 ns hm active n1 n2 e1' e2
    (_, Tick _ e2') -> moreRestrictive s1 s2 ns hm active n1 n2 e1 e2'
    (Var i, _) | m <- idName i
               , not $ E.isSymbolic m h1
               , not $ HS.member m ns
               , not $ (m, e2) `elem` n1
               , Just e <- E.lookup m h1 ->
                 moreRestrictive s1 s2 ns hm active ((m, e2):n1) n2 e e2
    (_, Var i) | m <- idName i
               , not $ E.isSymbolic m h2
               , not $ HS.member m ns
               , not $ (m, e1) `elem` n2
               , Just e <- E.lookup m h2 ->
                 moreRestrictive s1 s2 ns hm active n1 ((m, e1):n2) e1 e
    (Var i1, Var i2) | HS.member (idName i1) ns
                     , idName i1 == idName i2 -> Right hm
                     | HS.member (idName i1) ns -> Left Nothing
                     | HS.member (idName i2) ns -> Left Nothing
    (Var i, _) | E.isSymbolic (idName i) h1
               , (hm', hs) <- hm
               , Nothing <- HM.lookup i hm' -> Right (HM.insert i (inlineEquiv [] h2 ns e2) hm', hs)
               | E.isSymbolic (idName i) h1
               , Just e <- HM.lookup i (fst hm)
               , e == inlineEquiv [] h2 ns e2 -> Right hm
               -- this last case means there's a mismatch
               | E.isSymbolic (idName i) h1 -> Left Nothing
               | not $ (idName i, e2) `elem` n1
               , not $ HS.member (idName i) ns -> error $ "unmapped variable " ++ (show i)
    (_, Var i) | E.isSymbolic (idName i) h2 -> Left Nothing -- sym replaces non-sym
               | not $ (idName i, e1) `elem` n2
               , not $ HS.member (idName i) ns -> error $ "unmapped variable " ++ (show i)
    (App f1 a1, App f2 a2) | Right hm_fa <- moreResFA -> Right hm_fa
                           | Left (Just _) <- moreResFA -> moreResFA
                           | not (hasFuncType e1)
                           , not (hasFuncType e2)
                           , not active
                           , Var (Id m1 _):_ <- unApp (modifyASTs stripTicks e1)
                           , Var (Id m2 _):_ <- unApp (modifyASTs stripTicks e2)
                           , nameOcc m1 == nameOcc m2 ->
                                let
                                    v_rep = HM.toList $ fst hm
                                    e1' = replaceVars e1 v_rep
                                    h2' = E.mapConc (flip replaceVars v_rep) h2 -- foldr (\(Id n _, e) -> E.insert n e) h2 (HM.toList $ fst hm)
                                    ls1 = s2 { expr_env = h2', curr_expr = CurrExpr Evaluate e1' }
                                    ls2 = s2 { curr_expr = CurrExpr Evaluate e2 }

                                    in1 = inlineFull (HS.toList ns) (expr_env s1)
                                    in2 = inlineFull (HS.toList ns) (expr_env s2)
                                in
                                -- let pg = mkPrettyGuide (ls1, ls2) in
                                -- trace ("LEMMA " ++ (folder_name $ track s2) ++ " " ++ (folder_name $ track s1)
                                --                 ++ " -\ncurr_expr s1 = " ++ printHaskellDirtyPG pg (in1 $ exprExtract s1)
                                --                 ++ "\ncurr_expr s2 = " ++ printHaskellDirtyPG pg (in2 $ exprExtract s2)
                                --                 ++ "\ne1 = " ++  printHaskellDirtyPG pg (in1 e1)
                                --                 ++ "\ne2 = " ++ printHaskellDirtyPG pg (in2 e2))
                                Left (Just (e2, mkProposedLemma "lemma" s1 s2 ls2 ls1))
        where
            moreResFA = do
                hm_f <- moreRestrictive s1 s2 ns hm active n1 n2 f1 f2
                moreRestrictive s1 s2 ns hm_f False n1 n2 a1 a2
    -- TODO ignoring lam use; these are never used seemingly
    -- TODO shouldn't lead to non-termination
    {-
    (App (Lam _ i b) a, _) -> let e1' = replaceASTs (Var i) a b
                              in trace ("LAM L" ++ show i) $ moreRestrictive s1 s2 ns hm n1 n2 e1' e2
    (_, App (Lam _ i b) a) -> let e2' = replaceASTs (Var i) a b
                              in trace ("LAM R" ++ show i) $ moreRestrictive s1 s2 ns hm n1 n2 e1 e2'
    -}
    -- These two cases should come after the main App-App case.  If an
    -- expression pair fits both patterns, then discharging it in a way that
    -- does not add any extra proof obligations is preferable.
    (App _ _, _) | e1':_ <- unApp e1
                 , (Prim _ _) <- inlineTop [] h1 e1'
                 , T.isPrimType $ typeOf e1
                 , T.isPrimType $ typeOf e2
                 , isSWHNF $ (s2 { curr_expr = CurrExpr Evaluate e2 }) ->
                                  let (hm', hs) = hm
                                  in Right (hm', HS.insert (inlineFull [] h1 e1, inlineFull [] h2 e2) hs)
    (_, App _ _) | e2':_ <- unApp e2
                 , (Prim _ _) <- inlineTop [] h1 e2'
                 , T.isPrimType $ typeOf e2
                 , T.isPrimType $ typeOf e1
                 , isSWHNF $ (s1 { curr_expr = CurrExpr Evaluate e1 }) ->
                                  let (hm', hs) = hm
                                  in Right (hm', HS.insert (inlineFull [] h1 e1, inlineFull [] h2 e2) hs)
    -- We just compare the names of the DataCons, not the types of the DataCons.
    -- This is because (1) if two DataCons share the same name, they must share the
    -- same type, but (2) "the same type" may be represented in different syntactic
    -- ways, most significantly bound variable names may differ
    -- "forall a . a" is the same type as "forall b . b", but fails a syntactic check.
    (Data (DataCon d1 _), Data (DataCon d2 _))
                                  | d1 == d2 -> Right hm
                                  | otherwise -> Left Nothing
    -- We neglect to check type equality here for the same reason.
    (Prim p1 _, Prim p2 _) | p1 == p2 -> Right hm
                           | otherwise -> Left Nothing
    (Lit l1, Lit l2) | l1 == l2 -> Right hm
                     | otherwise -> Left Nothing
    (Lam lu1 i1 b1, Lam lu2 i2 b2)
                | lu1 == lu2
                , i1 == i2 ->
                  let ns' = HS.insert (idName i1) ns
                  -- no need to insert twice over because they're equal
                  in moreRestrictive s1 s2 ns' hm active n1 n2 b1 b2
                | otherwise -> Left Nothing
    -- ignore types, like in exprPairing
    (Type _, Type _) -> Right hm
    -- new Let handling
    -- TODO does this not account for bindings properly?
    -- TODO only works properly if both binding lists are the same length
    -- I can just discard cases where they aren't for now
    (Let binds1 e1', Let binds2 e2') ->
                let pairs = (e1', e2'):(zip (map snd binds1) (map snd binds2))
                    ins (i_, e_) h_ = E.insert (idName i_) e_ h_
                    h1' = foldr ins h1 binds1
                    h2' = foldr ins h2 binds2
                    s1' = s1 { expr_env = h1' }
                    s2' = s2 { expr_env = h2' }
                    mf hm_ (e1_, e2_) = moreRestrictive s1' s2' ns hm_ active n1 n2 e1_ e2_
                in
                if length binds1 == length binds2
                then foldM mf hm pairs
                else Left Nothing
    -- TODO if scrutinee is symbolic var, make Alt vars symbolic?
    -- TODO id equality never checked; does it matter?
    (Case e1' i1 a1, Case e2' i2 a2)
                | Right hm' <- b_mr ->
                  -- add the matched-on exprs to the envs beforehand
                  let h1' = E.insert (idName i1) e1' h1
                      h2' = E.insert (idName i2) e2' h2
                      s1' = s1 { expr_env = h1' }
                      s2' = s2 { expr_env = h2' }
                      mf hm_ (e1_, e2_) = moreRestrictiveAlt s1' s2' ns hm_ False n1 n2 e1_ e2_
                      l = zip a1 a2
                  in foldM mf hm' l
                | otherwise -> b_mr
                where
                    b_mr = moreRestrictive s1 s2 ns hm active n1 n2 e1' e2'
    (Cast e1' c1, Cast e2' c2) | c1 == c2 ->
        moreRestrictive s1 s2 ns hm active n1 n2 e1' e2'
    _ -> Left Nothing

replaceVars :: Expr -> [(Id, Expr)] -> Expr
replaceVars = foldr (\(Id n _, e) -> replaceVar n e)

-- These helper functions have safeguards to avoid cyclic inlining.
-- TODO remove ticks with this?
inlineTop :: [Name] -> ExprEnv -> Expr -> Expr
inlineTop acc h v@(Var (Id n _))
    | n `elem` acc = v
    | E.isSymbolic n h = v
    | Just e <- E.lookup n h = inlineTop (n:acc) h e
inlineTop acc h (Tick _ e) = inlineTop acc h e
inlineTop _ _ e = e

inlineFull :: [Name] -> ExprEnv -> Expr -> Expr
inlineFull acc h v@(Var (Id n _))
    | n `elem` acc = v
    | E.isSymbolic n h = v
    | Just e <- E.lookup n h = inlineFull (n:acc) h e
inlineFull acc h e = modifyChildren (inlineFull acc h) e

inlineEquiv :: [Name] -> ExprEnv -> HS.HashSet Name -> Expr -> Expr
inlineEquiv acc h ns v@(Var (Id n _))
    | n `elem` acc = v
    | E.isSymbolic n h = v
    | HS.member n ns = v
    | Just e <- E.lookup n h = inlineEquiv (n:acc) h ns e
inlineEquiv acc h ns e = modifyChildren (inlineEquiv acc h ns) e

-- ids are the same between both sides; no need to insert twice
moreRestrictiveAlt :: StateET ->
                      StateET ->
                      HS.HashSet Name ->
                      (HM.HashMap Id Expr, HS.HashSet (Expr, Expr)) ->
                      Bool -> -- active expression
                      [(Name, Expr)] -> -- ^ variables inlined previously on the LHS
                      [(Name, Expr)] -> -- ^ variables inlined previously on the RHS
                      Alt ->
                      Alt ->
                      Either (Maybe (Expr, Lemma)) (HM.HashMap Id Expr, HS.HashSet (Expr, Expr))
moreRestrictiveAlt s1 s2 ns hm active n1 n2 (Alt am1 e1) (Alt am2 e2) =
  if altEquiv am1 am2 then
  case am1 of
    DataAlt _ t1 -> let ns' = foldr HS.insert ns $ map idName t1
                    in moreRestrictive s1 s2 ns' hm active n1 n2 e1 e2
    _ -> moreRestrictive s1 s2 ns hm active n1 n2 e1 e2
  else Left Nothing

-- check only the names for DataAlt
altEquiv :: AltMatch -> AltMatch -> Bool
altEquiv (DataAlt dc1 ids1) (DataAlt dc2 ids2) =
  let DataCon dn1 _ = dc1
      DataCon dn2 _ = dc2
      n1 = map idName ids1
      n2 = map idName ids2
  in
  dn1 == dn2 && n1 == n2
altEquiv (LitAlt l1) (LitAlt l2) = l1 == l2
altEquiv Default Default = True
altEquiv _ _ = False

validMap :: State t -> State t -> HM.HashMap Id Expr -> Bool
validMap s1 s2 hm =
  let hm_list = HM.toList hm
      check (_, e) = (not $ isSWHNF $ s1 { curr_expr = CurrExpr Evaluate e })
                  || (not $ isSWHNF $ s2 { curr_expr = CurrExpr Evaluate e })
                  || isPrimType (typeOf e)
  in foldr (&&) True (map check hm_list)

restrictHelper :: StateET ->
                  StateET ->
                  HS.HashSet Name ->
                  Either (Maybe (Expr, Lemma)) (HM.HashMap Id Expr, HS.HashSet (Expr, Expr)) ->
                  Either (Maybe (Expr, Lemma)) (HM.HashMap Id Expr, HS.HashSet (Expr, Expr))
restrictHelper s1 s2 ns hm_hs = restrictAux s1 s2 ns hm_hs

restrictAux :: StateET ->
               StateET ->
               HS.HashSet Name ->
               Either (Maybe (Expr, Lemma)) (HM.HashMap Id Expr, HS.HashSet (Expr, Expr)) ->
               Either (Maybe (Expr, Lemma)) (HM.HashMap Id Expr, HS.HashSet (Expr, Expr))
restrictAux s1 s2 ns (Right hm) =
  moreRestrictive s1 s2 ns hm True [] [] (exprExtract s1) (exprExtract s2)
restrictAux _ _ _ left = left

syncSymbolic :: StateET -> StateET -> (StateET, StateET)
syncSymbolic s1 s2 =
  let f (E.SymbObj _) e2 = e2
      f e1 _ = e1
      h1 = E.unionWith f (expr_env s1) (expr_env s2)
      h2 = E.unionWith f (expr_env s2) (expr_env s1)
  in
  assert (map idName (E.symbolicIds h1) == map idName (E.symbolicIds h2)) $ (s1 { expr_env = h1 }, s2 { expr_env = h2 })

obligationWrap :: HS.HashSet (Expr, Expr) -> Maybe PathCond
obligationWrap obligations =
    let obligation_list = HS.toList obligations
        eq_list = map (\(e1, e2) -> App (App (Prim Eq TyUnknown) e1) e2) obligation_list
        conj = foldr1 (\o1 o2 -> App (App (Prim And TyUnknown) o1) o2) eq_list
    in
    if null eq_list
    then Nothing
    else Just $ ExtCond (App (Prim Not TyUnknown) conj) True

checkObligations :: S.Solver solver =>
                    solver ->
                    StateET ->
                    StateET ->
                    HS.HashSet (Expr, Expr) ->
                    IO (S.Result () ())
checkObligations solver s1 s2 obligation_set | not $ HS.null obligation_set =
    case obligationWrap $ modifyASTs stripTicks obligation_set of
        Nothing -> applySolver solver P.empty s1 s2
        Just allPO -> applySolver solver (P.insert allPO P.empty) s1 s2
  | otherwise = return $ S.UNSAT ()

-- shortcut:  don't invoke Z3 if there are no path conds
applySolver :: S.Solver solver =>
               solver ->
               PathConds ->
               StateET ->
               StateET ->
               IO (S.Result () ())
applySolver solver extraPC s1 s2 =
    let unionEnv = E.union (expr_env s1) (expr_env s2)
        rightPC = P.toList $ path_conds s2
        unionPC = foldr P.insert (path_conds s1) rightPC
        allPC = foldr P.insert unionPC (P.toList extraPC)
        -- TODO what if I use extraPC here instead of allPC?
        newState = s1 { expr_env = unionEnv, path_conds = extraPC }
    in case (P.toList allPC) of
      [] -> return $ S.SAT ()
      _ -> do
           putStrLn ("APPLY SOLVER " ++ (show $ folder_name $ track s1))
           putStrLn (show $ P.number $ path_conds s1)
           putStrLn (show $ folder_name $ track s2)
           putStrLn (show $ P.number $ path_conds s2)
           S.check solver newState allPC

genLemmaHashSet :: S.Solver solver => solver -> HS.HashSet Name -> (StateET, StateET) -> [(Expr, Lemma)]
                -> TacticM (HS.HashSet Lemma)
genLemmaHashSet solver ns sts lems = return . HS.unions =<< mapM (genLemmaHashSet' solver ns sts) lems

genLemmaHashSet' :: S.Solver solver => solver -> HS.HashSet Name -> (StateET, StateET) -> (Expr, Lemma)
                 -> TacticM (HS.HashSet Lemma)
genLemmaHashSet' solver ns (s1, s2) (rep_e, lem) = do
    fresh <- freshNameN
    W.liftIO $ putStrLn "genLemmaHashSet' 1"
    f_s1 <- repFresh fresh s1
    W.liftIO $ putStrLn "genLemmaHashSet' 2"
    f_s2 <- repFresh fresh s2
    case (f_s1, f_s2) of
        (Just s1', Just s2') -> do
            let fr_lem = mkProposedLemma "gen" s1 s2 s1' s2'
            let in1 = inlineFull (HS.toList ns) (expr_env s1')
                in2 = inlineFull (HS.toList ns) (expr_env s2')
            let pg = mkPrettyGuide (rep_e, s1, s2, s1', s2')
            W.liftIO $ putStrLn $ "genLemmaHashSet'\nrep_e = " ++ printHaskellDirtyPG pg (in2 $ rep_e)
                            ++ "\ne1 = " ++  printHaskellDirtyPG pg (in1 $ exprExtract s1)
                            ++ "\ne2 = " ++ printHaskellDirtyPG pg (in2 $ exprExtract s2)
                            ++ "\ne1' = " ++  printHaskellDirtyPG pg (in1 $ exprExtract s1')
                            ++ "\ne2' = " ++ printHaskellDirtyPG pg (in2 $ exprExtract s2')

            return $ HS.fromList [fr_lem, lem]
        _ -> do
            let in1 = inlineFull (HS.toList ns) (expr_env s1)
                in2 = inlineFull (HS.toList ns) (expr_env s2)
            let pg = mkPrettyGuide (s1, s2)
            W.liftIO $ putStrLn $ "genLemmaHashSet' No rep fresh\nrep_e = " ++ printHaskellDirtyPG pg (in2 $ rep_e)
                            ++ "\nisJust1 = " ++ show (isJust f_s1)
                            ++ "\nisJust2 = " ++ show (isJust f_s2)
                            ++ "\ne1 = " ++  printHaskellDirtyPG pg (in1 $ exprExtract s1)
                            ++ "\ne2 = " ++ printHaskellDirtyPG pg (in2 $ exprExtract s2)

            return $ HS.singleton lem
    where
        repFresh fr s = do
            let s_rep_e = s { curr_expr = CurrExpr Evaluate rep_e }

                v = Id fr (typeOf rep_e)
                s_rep_fresh = s { curr_expr = CurrExpr Evaluate (Var v) }

            (e, b) <- replaceEqual solver ns s_rep_e s_rep_fresh s
            return $ if b
                        then Just (s { expr_env = E.union (E.insertSymbolic v (expr_env s)) (expr_env s1)
                                     , curr_expr = CurrExpr Evaluate e })
                        else Nothing

replaceEqual :: S.Solver solver => solver -> HS.HashSet Name -> StateET -> StateET -> StateET
             -> TacticM (Expr, Bool)
replaceEqual solver ns lhs_s rhs_s s = CM.runStateT (replaceEqual' solver ns lhs_s rhs_s s $ exprExtract s) False

replaceEqual' :: S.Solver solver => solver -> HS.HashSet Name -> StateET -> StateET -> StateET -> Expr
              -> CM.StateT Bool TacticM Expr
replaceEqual' solver ns lhs_s rhs_s
                       s2@(State { curr_expr = CurrExpr er _ }) e = do
    mr_sub <- CM.lift $ moreRestrictiveSingle solver ns lhs_s (s2 { curr_expr = CurrExpr Evaluate e })
    case mr_sub of
        Right hm -> do
            W.liftIO $ do
                  putStrLn "Right"
                  let in1 = inlineFull (HS.toList ns) (expr_env lhs_s)
                      in2 = inlineFull (HS.toList ns) (expr_env s2)
                  let pg = mkPrettyGuide (lhs_s, s2, e)
                  putStrLn $ "e1 = " ++  printHaskellDirtyPG pg (in1 $ exprExtract lhs_s)
                            ++ "\ne2 = " ++ printHaskellDirtyPG pg (in2 e)
            CM.put True
            return $ exprExtract rhs_s                 
        Left _ -> do
            W.liftIO $ do
                  putStrLn "Left"
                  let in1 = inlineFull (HS.toList ns) (expr_env lhs_s)
                      in2 = inlineFull (HS.toList ns) (expr_env s2)
                  let pg = mkPrettyGuide (lhs_s, s2, e)
                  putStrLn $ "e1 = " ++  printHaskellDirtyPG pg (in1 $ exprExtract lhs_s)
                            ++ "\ne2 = " ++ printHaskellDirtyPG pg (in2 e)
                  print e

            let ns' = foldr HS.insert ns (bind e)
            case e of
                Var (Id n _)
                    | not (n `HS.member` ns)
                    , Just e' <- E.lookup n (expr_env s2) -> do
                        W.liftIO . putStrLn $ "looked up " ++ show n
                        W.liftIO . putStrLn $ "e' = " ++ show e'
                        let ns'' = HS.insert n ns'
                        modifyChildrenM (replaceEqual' solver ns'' lhs_s rhs_s s2) e'
                    | otherwise -> do W.liftIO . putStrLn $ "skipped " ++ show n
                                              ++ "\nin ns = " ++ show (n `HS.member` ns)
                                              ++ "\nin expr_env s2 = " ++ show (isJust $ E.lookup n (expr_env s2))
                                      modifyChildrenM (replaceEqual' solver ns' lhs_s rhs_s s2) e
                _ -> modifyChildrenM (replaceEqual' solver ns' lhs_s rhs_s s2) e
    where
        bind (Lam _ i _) = [idName i]
        bind (Case _ i as) = idName i:concatMap altBind as
        bind (Let b _) = map (idName . fst) b
        bind _ = []

        altBind (Alt (DataAlt _ is) _) = map idName is
        altBind _ = []

-- extra filter on top of isJust for maybe_pairs
-- if restrictHelper end result is Just, try checking the corresponding PCs
-- for True output, there needs to be an entry for which that check succeeds
-- return the previous state pair that was used for the discharge
-- return Nothing if there was no discharge
-- if there are multiple, just return the first
-- TODO first pair is "current," second pair is the match from the past
-- TODO the third entry in a prev triple is the original for left or right
moreRestrictivePairAux :: S.Solver solver =>
                          solver ->
                          HS.HashSet Name ->
                          [(StateET, StateET, StateET)] ->
                          (StateET, StateET) ->
                          TacticM (Either (HS.HashSet Lemma) (PrevMatch EquivTracker))
moreRestrictivePairAux solver ns prev (s1, s2) = do
  let (s1', s2') = syncSymbolic s1 s2
      folder = folder_name . track
      mr (p1, p2, pc) =
          let
              pos_lem_name = "past_1 = " ++ folder p1
                          ++ " present_1 = " ++ folder s1
                          ++ " past_2 = " ++ folder p2
                          ++ " present_2 = " ++ folder s2
              (p1', p2') = syncSymbolic p1 p2
              hm_obs = restrictHelper p2' s2' ns $
                       restrictHelper p1' s1' ns (Right (HM.empty, HS.empty))
          in
          return . mapLeft (fmap (\(e, l) -> (e, l { lemma_name = pos_lem_name  })))
          $ fmap (\hm_obs' -> PrevMatch (s1, s2) (p1, p2) hm_obs' pc) hm_obs

  mr_res <- mapM mr prev

  let (possible_lemmas, possible_matches) = partitionEithers mr_res

      -- As a heuristic, take only lemmas where both sides are not in SWHNF
  possible_lemmas' <- genLemmaHashSet solver ns (s1', s2') $ catMaybes possible_lemmas
  let possible_lemmas'' = HS.filter (\(Lemma { lemma_lhs = s1, lemma_rhs = s2 }) ->
                                              not (isSWHNF s1)
                                           && not (isSWHNF s2)) possible_lemmas'

      mpc (PrevMatch _ (p1, p2) (hm, _) _) =
          andM [moreRestrictivePC solver p1 s1 hm, moreRestrictivePC solver p2 s2 hm]

  possible_matches' <- filterM mpc possible_matches
  -- check obligations individually rather than as one big group
  res_list <- W.liftIO (findM (\pm -> isUnsat =<< checkObligations solver s1 s2 (snd . conditions $ pm)) (possible_matches'))
  return $ maybe (Left possible_lemmas'') Right res_list
  where
      isUnsat (S.UNSAT _) = return True
      isUnsat _ = return False

-- the third entry in prev tuples is meaningless here
moreRestrictivePair :: S.Solver solver =>
                       solver ->
                       HS.HashSet Name ->
                       [(StateET, StateET)] ->
                       (StateET, StateET) ->
                       TacticM (Either (HS.HashSet Lemma) (PrevMatch EquivTracker))
moreRestrictivePair solver ns prev (s1, s2) =
  let prev' = map (\(p1, p2) -> (p1, p2, p2)) prev in
  moreRestrictivePairAux solver ns prev' (s1, s2)

moreRestrictiveSingle :: S.Solver solver => solver -> HS.HashSet Name -> StateET -> StateET
                      -> TacticM (Either (HS.HashSet Lemma) (HM.HashMap Id Expr))
moreRestrictiveSingle solver ns s1 s2 = do
    case restrictHelper s1 s2 ns $ Right (HM.empty, HS.empty) of
        Left (Just l) -> return . Left =<< genLemmaHashSet' solver ns (s1, s2) l
        Left Nothing -> return $ Left HS.empty
        Right (hm, obs) -> do
            more_res_pc <- moreRestrictivePC solver s1 s2 hm
            case more_res_pc of
                False -> return $ Left HS.empty
                True -> do
                    obs <- W.liftIO (checkObligations solver s1 s2 obs)
                    case isUnsat obs of
                        True -> return (Right hm)
                        False -> return $ Left HS.empty
    where
        isUnsat (S.UNSAT _) = True
        isUnsat _ = False

-- TODO tick adjusting here?
isIdentity :: (Id, Expr) -> Bool
isIdentity (i1, Tick _ e2) = isIdentity (i1, e2)
isIdentity (i1, (Var i2)) = i1 == i2
isIdentity _ = False

-- approximation should be the identity map
-- needs to be enforced, won't just happen naturally
moreRestrictiveEqual :: S.Solver solver =>
                        solver ->
                        HS.HashSet Name ->
                        Lemmas ->
                        StateET ->
                        StateET ->
                        TacticM (Maybe (PrevMatch EquivTracker))
moreRestrictiveEqual solver ns lemmas s1 s2 = do
  let h1 = expr_env s1
      h2 = expr_env s2
      s1' = s1 { expr_env = E.union h1 h2 }
      s2' = s2 { expr_env = E.union h2 h1 }
  pm_maybe <- moreRestrictivePairWithLemmasPast solver ns lemmas [(s2', s1')] (s1, s2)
  case pm_maybe of
    Left _ -> return Nothing
    Right (_, _, pm@(PrevMatch _ _ (hm, _) _)) ->
      -- TODO do something with the lemmas for logging later
      if foldr (&&) True (map isIdentity $ HM.toList hm)
      then return $ Just pm
      else return Nothing

-- This attempts to find a pair of equal expressions between the left and right
-- sides.  The state used for the left side stays constant, but the recursion
-- iterates through all of the states in the right side's history.
equalFoldL :: S.Solver solver =>
              solver ->
              HS.HashSet Name ->
              Lemmas ->
              [StateET] ->
              StateET ->
              TacticM (Maybe (PrevMatch EquivTracker))
equalFoldL solver ns lemmas prev2 s1 = do
  case prev2 of
    [] -> return Nothing
    p2:t -> do
      mre <- moreRestrictiveEqual solver ns lemmas s1 p2
      case mre of
        Just pm -> return $ Just pm
        _ -> equalFoldL solver ns lemmas t s1

-- TODO clean up code
-- This tries all of the allowable combinations for equality checking.  First
-- it tries matching the left-hand present state with all of the previously
-- encountered right-hand states.  If all of those fail, it tries matching the
-- right-hand present state with all of the previously encountered left-hand
-- states.
equalFold :: S.Solver solver =>
             solver ->
             HS.HashSet Name ->
             Lemmas ->
             (StateH, StateH) ->
             (StateET, StateET) ->
             TacticM (Maybe (PrevMatch EquivTracker, Side))
equalFold solver ns lemmas (sh1, sh2) (s1, s2) = do
  pm_l <- equalFoldL solver ns lemmas (s2:history sh2) s1
  case pm_l of
    Just pm -> return $ Just (pm, ILeft)
    _ -> do
      pm_r <- equalFoldL solver ns lemmas (s1:history sh1) s2
      case pm_r of
        Just pm' -> return $ Just (pm', IRight)
        _ -> return Nothing

tryEquality :: S.Solver s => Tactic s
tryEquality solver ns lemmas _ sh_pair (s1, s2) = do
  res <- equalFold solver ns lemmas sh_pair (s1, s2)
  case res of
    Just (pm, sd) -> do
      let (q1, q2) = case sd of
                       ILeft -> present pm
                       IRight -> swap $ present pm
      W.tell $ [Marker sh_pair $ Equality $ EqualMarker (s1, s2) (q1, q2)]
      return $ Success Nothing
    _ -> return (NoProof HS.empty)

backtrackOne :: StateH -> Maybe StateH
backtrackOne sh =
  case history sh of
    [] -> Nothing
    h:t -> Just $ sh {
                       latest = h
                     , history = t
                     }

-- This attempts to find a past-present combination that works for coinduction.
-- The left-hand present state stays fixed, but the recursion iterates through
-- all of the possible options for the right-hand present state.
coinductionFoldL :: S.Solver solver =>
                    solver ->
                    HS.HashSet Name ->
                    Lemmas ->
                    HS.HashSet Lemma ->
                    (StateH, StateH) ->
                    (StateET, StateET) ->
                    TacticM (Either (HS.HashSet Lemma) (Maybe (StateET, Lemma), Maybe (StateET, Lemma), PrevMatch EquivTracker))
coinductionFoldL solver ns lemmas gen_lemmas (sh1, sh2) (s1, s2) | not . isSWHNF $ inlineCurrExpr s1
                                                                 , not . isSWHNF $ inlineCurrExpr s2  = do
  let prev = prevFiltered (sh1, sh2)

  res <- moreRestrictivePairWithLemmas solver ns lemmas prev (s1, s2)
  case res of
    Right _ -> return res
    Left new_lems -> backtrack new_lems
  | otherwise = backtrack HS.empty
  where
      backtrack new_lems_ =
          case backtrackOne sh2 of
              Nothing -> return . Left $ HS.union new_lems_ gen_lemmas
              Just sh2' -> coinductionFoldL solver ns lemmas
                                       (HS.union new_lems_ gen_lemmas) (sh1, sh2') (s1, latest sh2')

      inlineCurrExpr s_@(State { expr_env = eenv, curr_expr = CurrExpr er cexpr}) =
          let
              cexpr' = inlineFull (HS.toList ns) eenv cexpr
          in
          s_ { curr_expr = CurrExpr er cexpr' }

tryCoinduction :: S.Solver s => Tactic s
tryCoinduction solver ns lemmas _ (sh1, sh2) (s1, s2) = do
  res_l <- coinductionFoldL solver ns lemmas HS.empty (sh1, sh2) (s1, s2)
  case res_l of
    Right (lem_l, lem_r, pm) -> do
      let cml = CoMarker {
        co_real_present = (s1, s2)
      , co_used_present = present pm
      , co_past = past pm
      , lemma_used_left = lem_l
      , lemma_used_right = lem_r
      }
      W.tell [Marker (sh1, sh2) $ Coinduction cml]
      return $ Success Nothing
    Left l_lemmas -> do
      res_r <- coinductionFoldL solver ns lemmas HS.empty (sh2, sh1) (s2, s1)
      case res_r of
        Right (lem_l', lem_r', pm') -> do
          let cmr = CoMarker {
            co_real_present = (s2, s1)
          , co_used_present = present pm'
          , co_past = past pm'
          , lemma_used_left = lem_l'
          , lemma_used_right = lem_r'
          }
          W.tell [Marker (sh1, sh2) $ Coinduction $ reverseCoMarker cmr]
          return $ Success Nothing
        Left r_lemmas -> return . NoProof $ HS.union l_lemmas r_lemmas

-------------------------------------------------------------------------------

data Lemmas = Lemmas { proposed_lemmas :: [ProposedLemma]
                     , proven_lemmas :: [ProvenLemma]
                     , disproven_lemmas :: [DisprovenLemma]}

emptyLemmas :: Lemmas
emptyLemmas = Lemmas [] [] []

insertProposedLemma :: S.Solver solver => solver -> HS.HashSet Name -> Lemma -> Lemmas -> TacticM Lemmas
insertProposedLemma solver ns lem lems@(Lemmas { proposed_lemmas = prop_lems
                                               , proven_lemmas = proven_lems
                                               , disproven_lemmas = disproven_lems }) = do
    same_as_proposed <- equivLemma solver ns lem prop_lems
    implied_by_proven <- moreRestrictiveLemma solver ns lem proven_lems
    implied_by_disproven <- anyM (\dl -> moreRestrictiveLemma solver ns dl [lem]) disproven_lems
    case same_as_proposed || implied_by_proven  || implied_by_disproven of
        True -> return lems
        False -> return lems { proposed_lemmas = lem:prop_lems }

proposedLemmas :: Lemmas -> [ProposedLemma]
proposedLemmas = proposed_lemmas

provenLemmas :: Lemmas -> [ProposedLemma]
provenLemmas = proven_lemmas

disprovenLemmas :: Lemmas -> [ProposedLemma]
disprovenLemmas = disproven_lemmas

replaceProposedLemmas :: [ProposedLemma] -> Lemmas -> Lemmas
replaceProposedLemmas pl lems = lems { proposed_lemmas = pl }

insertProvenLemma :: ProvenLemma -> Lemmas -> Lemmas
insertProvenLemma lem lems = lems { proven_lemmas = lem:proven_lemmas lems }

insertDisprovenLemma :: DisprovenLemma -> Lemmas -> Lemmas
insertDisprovenLemma lem lems = lems { disproven_lemmas = lem:disproven_lemmas lems }

moreRestrictiveLemma :: S.Solver solver => solver -> HS.HashSet Name -> Lemma -> [Lemma] -> TacticM Bool 
moreRestrictiveLemma solver ns (Lemma { lemma_lhs = l1_1, lemma_rhs = l1_2 }) lems = do
    mr <- moreRestrictivePair solver ns
                              (map (\(Lemma { lemma_lhs = l2_1, lemma_rhs = l2_2 }) -> (l2_1, l2_2)) lems)
                              (l1_1, l1_2)
    case mr of
        Left _ -> return False
        Right _ -> return True

-- TODO Is this correct?  See moreRestrictiveEqual
equivLemma :: S.Solver solver => solver -> HS.HashSet Name -> Lemma -> [Lemma] -> TacticM Bool 
equivLemma solver ns (Lemma { lemma_lhs = l1_1, lemma_rhs = l1_2 }) lems = do
    anyM (\(Lemma { lemma_lhs = l2_1, lemma_rhs = l2_2 }) -> do
                    mr1 <- moreRestrictivePair solver ns [(l2_1, l2_2)] (l1_1, l1_2)
                    mr2 <- moreRestrictivePair solver ns [(l1_1, l1_2)] (l2_1, l2_2)
                    case (mr1, mr2) of
                        (Right _, Right _) -> return True
                        _ -> return False) lems

-- TODO: Does substLemma need to do something more to check correctness of path constraints?
-- `substLemma state lemmas` tries to apply each proven lemma in `lemmas` to `state`.
-- In particular, for each `lemma = (lemma_l `equiv lemma_r` in the proven lemmas, it
-- searches for a subexpression `e'` of `state`'s current expression such that `e' <=_V lemma_l`.
-- If it find such a subexpression, it adds state[e'[V(x)/x]] to the returned
-- list of States.
substLemma :: S.Solver solver => solver -> HS.HashSet Name -> StateET -> Lemmas -> TacticM [(Lemma, StateET)]
substLemma solver ns s =
    mapMaybeM (\lem -> replaceMoreRestrictiveSubExprWithLemma solver ns lem s) . provenLemmas

replaceMoreRestrictiveSubExprWithLemma :: S.Solver solver => solver -> HS.HashSet Name -> Lemma -> StateET
                                       -> TacticM (Maybe (Lemma, StateET))
replaceMoreRestrictiveSubExprWithLemma solver ns
                                       lemma@(Lemma { lemma_lhs = lhs_s, lemma_rhs = rhs_s })
                                       s@(State { curr_expr = CurrExpr er _ }) = do
    (e, replaced) <- replaceMoreRestrictiveSubExpr solver ns lhs_s rhs_s s
    return $ if replaced then Just (lemma, s { curr_expr = CurrExpr er e }) else Nothing

replaceMoreRestrictiveSubExpr :: S.Solver solver => solver -> HS.HashSet Name -> StateET -> StateET -> StateET
                              -> TacticM (Expr, Bool)
replaceMoreRestrictiveSubExpr solver ns orig_s rep_s2 s =
    CM.runStateT (replaceMoreRestrictiveSubExpr' solver ns orig_s rep_s2 s $ exprExtract s) False

replaceMoreRestrictiveSubExpr' :: S.Solver solver => solver -> HS.HashSet Name -> StateET -> StateET -> StateET -> Expr
                               -> CM.StateT Bool (TacticM) Expr
replaceMoreRestrictiveSubExpr' solver ns lhs_s rhs_s
                                         s2@(State { curr_expr = CurrExpr er _ }) e = do
    replaced <- CM.get
    if not replaced then do 
        mr_sub <- CM.lift $ moreRestrictiveSingle solver ns lhs_s (s2 { curr_expr = CurrExpr Evaluate e })
        case mr_sub of
            Right hm -> do
                let v_rep = HM.toList hm

                    rhs_e' = replaceVars (inlineFull (HS.toList ns) (expr_env rhs_s) $ exprExtract rhs_s) v_rep

                CM.put True
                return rhs_e'                 
            Left _ -> do
                let ns' = foldr HS.insert ns (bind e)
                modifyChildrenM (replaceMoreRestrictiveSubExpr' solver ns' lhs_s rhs_s s2) e
    else return e
    where
        bind (Lam _ i _) = [idName i]
        bind (Case _ i as) = idName i:concatMap altBind as
        bind (Let b _) = map (idName . fst) b
        bind _ = []

        altBind (Alt (DataAlt _ is) _) = map idName is
        altBind _ = []

moreRestrictivePairWithLemmas :: S.Solver solver =>
                                 solver ->
                                 HS.HashSet Name ->
                                 Lemmas ->
                                 [(StateET, StateET)] ->
                                 (StateET, StateET) ->
                                 TacticM (Either (HS.HashSet Lemma) (Maybe (StateET, Lemma), Maybe (StateET, Lemma), PrevMatch EquivTracker))
moreRestrictivePairWithLemmas solver ns lemmas past (s1, s2) = do
    let (s1', s2') = syncSymbolic s1 s2
    xs1 <- substLemma solver ns s1' lemmas
    xs2 <- substLemma solver ns s2' lemmas

    let xs1' = (Nothing, s1'):(map (\(l, s) -> (Just l, s)) xs1)
        xs2' = (Nothing, s2'):(map (\(l, s) -> (Just l, s)) xs2)
        pairs = [ (pair1, pair2) | pair1 <- xs1', pair2 <- xs2' ]

    rp <- mapM (\((l1, s1_), (l2, s2_)) -> do
            mrp <- moreRestrictivePair solver ns past (s1_, s2_)
            -- TODO use synced or non-synced?
            let l1' = case l1 of
                  Nothing -> Nothing
                  Just lem1 -> Just (s1', lem1)
                l2' = case l2 of
                  Nothing -> Nothing
                  Just lem2 -> Just (s2', lem2)
            return $ fmap (l1', l2', ) mrp) pairs
    let (possible_lemmas, possible_matches) = partitionEithers rp

    case possible_matches of
        x:_ -> return $ Right x
        [] -> return . Left $ HS.unions possible_lemmas

-- TODO have a cleaner setup for these variations
moreRestrictivePairWithLemmasPast :: S.Solver solver =>
                                     solver ->
                                     HS.HashSet Name ->
                                     Lemmas ->
                                     [(StateET, StateET)] ->
                                     (StateET, StateET) ->
                                     TacticM (Either (HS.HashSet Lemma) (Maybe (StateET, Lemma), Maybe (StateET, Lemma), PrevMatch EquivTracker))
moreRestrictivePairWithLemmasPast solver ns lemmas past s_pair = do
    let (past1, past2) = unzip past
    xs_past1 <- mapM (\s_ -> substLemma solver ns s_ lemmas) past1
    xs_past2 <- mapM (\s_ -> substLemma solver ns s_ lemmas) past2
    let plain_past1 = map (\s_ -> (Nothing, s_)) past1
        plain_past2 = map (\s_ -> (Nothing, s_)) past2
        xs_past1' = plain_past1 ++ (map (\(l, s) -> (Just l, s)) $ concat xs_past1)
        xs_past2' = plain_past2 ++ (map (\(l, s) -> (Just l, s)) $ concat xs_past2)
        -- TODO is it fine to sync after lemma usage rather than before?
        -- TODO also record the lemmas used somehow?
        pair_past (_, p1) (_, p2) = syncSymbolic p1 p2
        past' = [pair_past pair1 pair2 | pair1 <- xs_past1', pair2 <- xs_past2']
    moreRestrictivePairWithLemmas solver ns lemmas past' s_pair

mkProposedLemma :: String -> StateET -> StateET -> StateET -> StateET -> ProposedLemma
mkProposedLemma lm_name or_s1 or_s2 s1 s2 =
    assert (map idName (E.symbolicIds (expr_env s1)) == map idName (E.symbolicIds (expr_env s2)))
          Lemma { lemma_name = lm_name
                , lemma_lhs = s1
                , lemma_rhs = s2
                , lemma_lhs_origin = folder_name . track $ or_s1
                , lemma_rhs_origin = folder_name . track $ or_s2
                , lemma_to_be_proven  =[(newStateH s1, newStateH s2)] }
