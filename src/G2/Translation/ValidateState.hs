{-# LANGUAGE OverloadedStrings, CPP, FlexibleContexts #-}

module G2.Translation.ValidateState ( validateStates
                                   , validateStatesGHC
                                   , loadStandard
                                   , loadToCheck
                                   , createDeclsStr
                                   , createDecls
                                   , runHPC
                                   , adjustDynFlags
                                   , loadSession
                                   , validateState
                                   , printStateOutput
                                   , toEnclodeFloat
                                    ) where

#if MIN_VERSION_GLASGOW_HASKELL(9,0,2,0)
import GHC.Driver.Session
import qualified GHC.Data.EnumSet as ES
#else
import DynFlags
import qualified EnumSet as ES
#endif

import GHC hiding (Name, entry, Id)
import GHC.LanguageExtensions

import GHC.Paths
import Control.Monad

import Data.Foldable (toList)
import Data.Either
import qualified Data.HashSet as HS
import Data.List
import Data.Maybe
import qualified Data.Text as T
import qualified Data.Text.IO as T
import qualified Data.Sequence as S
import Text.Regex
import Unsafe.Coerce
import qualified Data.HashMap.Lazy as H
import G2.Config
import G2.Initialization.MkCurrExpr
import G2.Interface.ExecRes as I
import G2.Language
import G2.Translation.Haskell
import G2.Translation.Interface
import G2.Translation.TransTypes
import G2.Lib.Printers
import Control.Exception

import System.Directory
import System.FilePath
import System.IO.Error
import System.Process
import System.Timeout

import Control.Monad.IO.Class

-- | Load the passed module(s) into GHC, and check that the `ExecRes` results are correct.
validateStates :: [FilePath] -> [FilePath] -> HS.HashSet (Maybe T.Text) -> String -> [String] -> [String] -> [GeneralFlag] -> String -> Bindings
               -> [ExecRes t]
               -> IO ( [Maybe Bool] -- ^ One bool per input `ExecRes`, indicating whether the results are correct or not
                                  -- Nothing in the case of a timeout
                     , Bool -- ^ Are all "Any" requirements satisfied?
                     )
validateStates proj src modN entry chAll chAny gflags comp_func b in_out = do
    runGhc (Just libdir) (do
        adjustDynFlags
        loadToCheck (map dirPath src ++ proj) src modN gflags
        rs_anys <- mapM (\er -> do
                let s = final_state er
                let pg = updatePGValNames (concatMap (map Data . dataCon) $ type_env s)
                       . updatePGTypeNames (type_env s)
                       . flip (foldr updateQualMods) (catMaybes $ HS.toList modN)
                       . setStrictCase True
                       $ mkPrettyGuide ()
                _ <- createDecls pg s (H.filter (\x -> adt_source x == ADTG2Generated) (type_env s))
                validateStatesGHC pg comp_func modN entry chAll chAny b er) in_out
        let chck_anys = all or . transpose $ map snd rs_anys
        return (map fst rs_anys, chck_anys))

-- | Convert g2 generated types into readable string that aim to notify the environment about the types generated by g2
-- The type is formatted as the following:
-- data name bound_ids = datacons 
creatDeclStr :: PrettyGuide -> State t -> (Name, AlgDataTy) -> String
creatDeclStr pg s (x, DataTyCon{data_cons = dcs, bound_ids = is}) =
    let
        x' = T.unpack $ printName pg x
        ids' = T.unpack . T.intercalate " " $ map (printHaskellPG pg s . Var) is
        wrapParens str = "(" <> str <> ")" 
        dc_decls = map (\dc -> printHaskellPG pg s (Data dc) <> " " <> T.intercalate " " (map (wrapParens . mkTypeHaskellPG pg) (argumentTypes (typeOf (tyvar_env s) dc)))) dcs
        all_dc_decls = T.unpack $ T.intercalate " | " dc_decls
        derive_eq = if not (any isTyFun $ concatMap (argumentTypes . typeOf (tyvar_env s)) dcs) then " deriving Eq" else ""
    in
    "data " ++ x' ++ " " ++ ids'++ " = " ++ all_dc_decls ++ derive_eq
creatDeclStr _ _ _ = error "creatDeclStr: unsupported AlgDataTy"

-- | Compile with GHC, and check that the output we got is correct for the input
validateStatesGHC :: GhcMonad m => PrettyGuide -> String -> HS.HashSet (Maybe T.Text) -> String -> [String] -> [String] -> Bindings -> ExecRes t -> m (Maybe Bool, [Bool])
validateStatesGHC pg comp_func modN entry chAll chAny b er@(ExecRes {final_state = s, conc_out = out}) = do
    (v, chAllR, chAnyR) <- runCheck pg comp_func modN entry chAll chAny b er

    v' <- liftIO . timeout (5 * 10 * 1000) $ (unsafeCoerce v :: IO (Either SomeException Bool))
    let outStr = T.unpack $ printHaskell s out
    let v'' = case v' of
                    Nothing -> Nothing
                    Just (Left e) | show e == "<<timeout>>" -> Nothing
                                  | otherwise -> Just (outStr == "error" || outStr == "undefined" || outStr == "?")
                    Just (Right b) -> Just (b && outStr /= "error" && outStr /= "undefined")

    chAllR' <- liftIO $ (mapM unsafeCoerce chAllR :: IO [Either SomeException Bool])
    let chAllR'' = rights chAllR'

    chAnyR' <- liftIO $ (mapM unsafeCoerce chAnyR :: IO [Either SomeException Bool])
    let chAnyR'' = rights chAnyR'

    return $ (fmap (&& and chAllR'') v'', chAnyR'')

createDeclsStr :: PrettyGuide -> State t -> TypeEnv -> [String]
createDeclsStr pg s = map (creatDeclStr pg s) . H.toList

createDecls :: GhcMonad m => PrettyGuide -> State t -> TypeEnv -> m ()
createDecls pg s = mapM_ runDecls . createDeclsStr pg s

adjustDynFlags :: GhcMonad m => m ()
adjustDynFlags = do
    dyn <- getSessionDynFlags
    let dyn2 = foldl' xopt_set dyn [MagicHash, UnboxedTuples, DataKinds, BangPatterns]
        dyn3 = wopt_unset dyn2 Opt_WarnOverlappingPatterns
        dyn4 = dyn3 { generalFlags = ES.insert Opt_Hpc (generalFlags dyn3) }
    _ <- setSessionDynFlags dyn4
    return ()

runCheck :: GhcMonad m => PrettyGuide -> String -> HS.HashSet (Maybe T.Text) -> String -> [String] -> [String] -> Bindings -> ExecRes t -> m (HValue, [HValue], [HValue])
runCheck init_pg comp_func modN entry chAll chAny b er@(ExecRes {final_state = s, conc_args = ars, conc_out = out}) = do
    let Left (v, _) = findFunc (tyvar_env s) (T.pack entry) (HS.toList modN) (expr_env s)
    let e = mkApp $ Var v:ars
    let pg = updatePGValAndTypeNames e
           . updatePGValAndTypeNames out
           $ updatePGValAndTypeNames (varIds v) init_pg

    let (mvTxt, arsTxt, outTxt, _) = printInputOutput pg v b er 
        mvStr = T.unpack mvTxt
        arsStr = T.unpack arsTxt
        outStr = T.unpack outTxt

    let arsType = T.unpack $ mkTypeHaskellPG pg (typeOf (tyvar_env s) e)
        outType = T.unpack $ mkTypeHaskellPG pg (typeOf (tyvar_env s) out)

    -- If we are returning a primitive type (Int#, Float#, etc.) wrap in a constructor so that `==` works
    let pr_con = case typeOf (tyvar_env s) out of
                        TyLitInt -> "I# "
                        TyLitDouble -> "D# "
                        TyLitFloat -> "F# "
                        TyLitChar -> "C# "
                        _ -> ""

    let comp_func' = case comp_func of
                        x:_ | 'a' <= x && x <= 'z' -> "`" ++ comp_func ++ "`"
                        _ -> comp_func

    let chck = case outStr == "error" || outStr == "undefined" || outStr == "?" of
                    False -> mvStr ++ "Control.Exception.try (evaluate (" ++ pr_con ++ "(" ++ arsStr ++ ") " ++ comp_func' ++ " " ++ pr_con ++ "("
                                        ++ outStr ++ " :: " ++ outType ++ ")" ++ ")) :: IO (Either SomeException Bool)"
                    True -> mvStr ++ "Control.Exception.try (evaluate ( (" ++ pr_con ++ "(" ++ arsStr ++ " :: " ++ arsType ++ ")" ++
                                                    ") " ++ comp_func' ++ " " ++ pr_con ++ "(" ++ arsStr ++ "))) :: IO (Either SomeException Bool)"
    v' <- compileExpr chck

    let chArgs = ars ++ [out] 
    let chAllStr = map (\f -> T.unpack $ printHaskellPG pg s $ mkApp ((simpVar $ T.pack f):chArgs)) chAll
    let chAllStr' = map (\str -> "Control.Exception.try (evaluate (" ++ str ++ ")) :: IO (Either SomeException Bool)") chAllStr

    chAllR <- mapM compileExpr chAllStr'

    let chAnyStr = map (\f -> T.unpack $ printHaskellPG pg s $ mkApp ((simpVar $ T.pack f):chArgs)) chAny
    let chAnyStr' = map (\str -> "Control.Exception.try (evaluate (" ++ str ++ ")) :: IO (Either SomeException Bool)") chAnyStr

    chAnyR <- mapM compileExpr chAnyStr'

    return $ (v', chAllR, chAnyR)

loadToCheck :: GhcMonad m => [FilePath] -> [FilePath] -> HS.HashSet (Maybe T.Text) -> [GeneralFlag] -> m ()
loadToCheck proj src modN gflags = do
        _ <- loadProj Nothing proj src gflags simplTranslationConfig

        let mdN = map (mkModuleName . T.unpack) . catMaybes $ HS.toList modN
        let imD = map simpleImportDecl mdN

        imps <- liftIO $ concat <$> mapM getImports src

        let imp_decls = map (IIDecl . simpleImportDecl . mkModuleName) imps

        setContext (map IIDecl imD ++ loadStandardSet ++ imp_decls)

getImports :: FilePath -> IO [String]
getImports src = do
    srcCode <- readFile src
    get srcCode
    where
        get str = do
            let r = mkRegex "^import[ \t]*([a-zA-Z0-9_.]*)"
            case matchRegexAll r str of
                Just (_, _, after, imps) -> (imps ++) <$> get after
                Nothing -> return []

loadStandard :: Ghc ()
loadStandard = setContext loadStandardSet

loadStandardSet :: [InteractiveImport]
loadStandardSet =
    let primN = mkModuleName "GHC.Prim"
        primImD = simpleImportDecl primN

        extsN = mkModuleName "GHC.Exts"
        extsImD = simpleImportDecl extsN

        prN = mkModuleName "Prelude"
        prImD = simpleImportDecl prN

        exN = mkModuleName "Control.Exception"
        exImD = simpleImportDecl exN

        coerceN = mkModuleName "Data.Coerce"
        coerceImD = simpleImportDecl coerceN

        charN = mkModuleName "Data.Char"
        charD = simpleImportDecl charN
    in
    [IIDecl primImD, IIDecl extsImD, IIDecl prImD, IIDecl exImD, IIDecl coerceImD, IIDecl charD]

simpVar :: T.Text -> Expr
simpVar s = Var (Id (Name s Nothing 0 ProvOther) TyBottom)

runHPC :: FilePath -> String -> String -> String -> [ExecRes t] -> IO ()
runHPC src meas_with modN entry in_out = do
    let calls = map (\(ExecRes { final_state = s, conc_args = i, conc_out = o })-> toCall modN entry s i o) in_out

    runHPC' src meas_with modN calls

-- Compile with GHC, and check that the output we got is correct for the input
runHPC' :: FilePath -> String -> String -> [String] -> IO ()
runHPC' src meas_with modN ars = do
    imps <- getImports src
    srcCode <- readFile src
    let ext = dropWhile (/= '.') src
        dir = takeDirectory src
        -- srcCode' = removeModule modN srcCode

    let spces = "  "

    let meas_with' = if meas_with == "" then "" else " $ " ++ meas_with ++ " "
        chck = intercalate ("\n" ++ spces) $ map (\s -> "Ex.try (print " ++ meas_with' ++ "(" ++ s ++ ")) :: IO (Either Ex.SomeException ())") ars

    let mainFunc = "\n\nmain_internal_g2 :: IO ()\nmain_internal_g2 =do\n"
                            ++ spces ++ chck ++ "\n" ++ spces ++  "return ()\n" ++ spces


    createDirectoryIfMissing False "hpc"
    let origMod = modN
        origFile = "hpc/" ++ origMod
        mainMod = "Main_" ++ modN
        mainFile = "hpc/" ++ mainMod

    let handleExists e
          | isDoesNotExistError e = return ()
          | otherwise = throwIO e
    removeFile (mainMod ++ ".tix") `catch` handleExists

    writeFile (origFile ++ ext) srcCode
    let main_imps = intercalate "\n" $ map ("import " ++) imps
    writeFile (mainFile ++ ".hs") ("module CallForHPC where\n\nimport qualified Control.Exception as Ex\nimport Data.Char\nimport " ++ modN ++ "\n" ++ main_imps ++ "\n" ++ mainFunc)

    callProcess "ghc" $ ["-main-is", "CallForHPC.main_internal_g2", "-fhpc"
                        , mainFile ++ ".hs", src, "-o", mainFile, "-O0", "-i" ++ dir]
    callProcess ("./" ++ mainFile) []

    callProcess "hpc" ["report", mainMod, "--per-module", "--srcdir=hpc", "--hpcdir=../.hpc"]

    -- putStrLn mainFunc

toCall :: String -> String -> State t -> [Expr] -> Expr -> String
toCall modN entry s ars _ =
    let
        Left (v, _) = findFunc (tyvar_env s) (T.pack entry) [Just $ T.pack modN] (expr_env s)
        e = mkApp (Var v:ars)
        t = typeOf (tyvar_env s) e
        pg = setStrictCase True $ mkPrettyGuide (exprNames e)

        str_e = printHaskellPG pg s $ e
        str_t = mkTypeHaskellPG pg t
    in
    T.unpack $ str_e <> " :: " <> str_t

loadSession :: GhcMonad m => [FilePath] -> [FilePath] -> HS.HashSet (Maybe T.Text) -> [GeneralFlag] -> m ()
loadSession proj src modN gflags = do 
    adjustDynFlags
    loadToCheck (map dirPath src ++ proj) src modN gflags

-- | Load the passed module(s) into GHC, and check that the `ExecRes` results are correct.
validateState :: GhcMonad m => String -> HS.HashSet (Maybe T.Text) -> String -> [String] -> [String] -> Bindings
               -> ExecRes t
               -> m ( Maybe Bool -- ^ One bool per input `ExecRes`, indicating whether the results are correct or not
                                  -- Nothing in the case of a timeout
                     )
validateState comp_func modN entry chAll chAny b in_out = do
        let s = final_state in_out
        let pg = updatePGValNames (concatMap (map Data . dataCon) $ type_env s)
                       . updatePGTypeNames (type_env s)
                       . flip (foldr updateQualMods) (catMaybes $ HS.toList modN)
                       . setStrictCase True
                       $ mkPrettyGuide ()
        _ <- createDecls pg s (H.filter (\x -> adt_source x == ADTG2Generated) (type_env s))
        rs_anys <- validateStatesGHC pg comp_func modN entry chAll chAny b in_out
        
        return (fst rs_anys)

printStateOutput :: Config -> Id -> Bindings
               -> Maybe (Maybe Bool)
               -> ExecRes t
               -> IO ()
printStateOutput config entry b m_valid exec_res@(ExecRes { final_state = s }) = do
    let print_valid = isJust m_valid
    let val = fromMaybe (Just True) m_valid

    when print_valid (putStr (case val of
                                        Just True -> "✓ "
                                        Just False -> "✗ "
                                        Nothing -> "✗TO "))

    let pg = mkPrettyGuide (exprNames $ conc_args exec_res)
    let (mvp, inp, outp, handles) = printInputOutput pg entry b exec_res
        sym_gen_out = fmap (printHaskellPG pg s) $ conc_sym_gens exec_res
        
    let print_method = \m i o -> m <> i <> " = " <> o 

    when (print_output config ) (do
        case sym_gen_out of
            S.Empty -> T.putStrLn $ print_method mvp inp outp
            _ -> T.putStrLn $ print_method mvp inp outp <> "\t| generated: " <> T.intercalate ", " (toList sym_gen_out)
        if handles /= "" then T.putStrLn handles else return ())


toEnclodeFloat :: ASTContainer m Expr => m -> m
toEnclodeFloat = modifyASTs go
    where
        go (App (Data (DataCon { dc_name = dcn })) (Lit (LitFloat f)))
            | not (isNaN f), not (isInfinite f), not (isNegativeZero f), nameOcc dcn == "F#" =
                let (m, n) = decodeFloat f in mkApp [encFloat, iCon $ Lit (LitInteger m), iCon $ Lit (LitInt $ toInteger n)]
        go (App (Data (DataCon { dc_name = dcn })) (Lit (LitDouble f)))
            | not (isNaN f), not (isInfinite f), not (isNegativeZero f), nameOcc dcn == "D#" =
                let (m, n) = decodeFloat f in mkApp [encFloat, iCon $ Lit (LitInteger m), iCon $ Lit (LitInt $ toInteger n)]
        go (Lit (LitFloat f))
            | not (isNaN f), not (isInfinite f), not (isNegativeZero f) =
                let (m, n) = decodeFloat f in mkApp [encFloat, iCon $ Lit (LitInteger m), iCon $ Lit (LitInt $ toInteger n)]
        go (Lit (LitDouble f))
            | not (isNaN f), not (isInfinite f), not (isNegativeZero f) =
                let (m, n) = decodeFloat f in mkApp [encFloat, iCon $ Lit (LitInteger m), iCon $ Lit (LitInt $ toInteger n)]
        go e = e

        iCon = App (Data (DataCon { dc_name = Name "Z#" Nothing 0 ProvOther, dc_type = TyUnknown, dc_exist_tyvars = [], dc_univ_tyvars = [] }))
        encFloat = Var (Id (Name "encodeFloat" Nothing 0 ProvOther) TyUnknown)